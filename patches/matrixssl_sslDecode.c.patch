--- matrixssl-3-7-2b-open-original/matrixssl/sslDecode.c	2015-03-18 20:57:06.000000000 +0000
+++ matrixssl-3-7-2b-open/matrixssl/sslDecode.c	2016-02-25 11:12:50.000000000 +0000
@@ -1322,9 +1322,16 @@ static int32 parseSSLHandshake(ssl_t *ss
 {
 	unsigned char	*c, *end;
 	unsigned char	hsType;
+	// variables used when walking through client provided cipher list
+	// all indexes are relative to our supportedCiphers list (see cipherSuite.c)
+	//   cipherIndex is the current tested cipher
+	//   bestCipherIndex is the strongest cipher according to our list
+	//   firstCipherIndex is the first cipher in the client's list
+	int16	 cipherIndex, bestCipherIndex, firstCipherIndex;
 	int32			rc, i = 0;
+	sslCipherSpec_t	*foundCipher;
 	short			renegotiationExt;
-	uint32			hsLen, extLen, extType, cipher = 0;
+	uint32			hsLen, extLen, extType, cipher = 0, bestCipher = 0;
 	unsigned char	hsMsgHash[SHA384_HASH_SIZE];
 	void			*pkiData = ssl->userPtr;
 
@@ -1416,6 +1423,14 @@ static int32 parseSSLHandshake(ssl_t *ss
 #endif /* SERVER && USE_ECC_CIPHER_SUITE */
 
 
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+/*	Remember if we forced a downgrade so we know which versions to compare
+		and we don't reject the handshake if TLS_FALLBACK_SCSV is specified.
+*/
+		int16 forcedMin = 0;
+#endif
+
+
 	rc = MATRIXSSL_SUCCESS;
 	c = (unsigned char*)inbuf;
 	end = (unsigned char*)(inbuf + len);
@@ -1741,7 +1756,12 @@ SKIP_HSHEADER_PARSE:
 		Client should always be sending highest supported protocol.  Server
 		will reply with a match or a lower version if enabled (or forced).
 */
+
+
 		if (ssl->majVer != 0) {
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+			forcedMin = 1;
+#endif
 			/* If our forced server version is a later protocol than their
 				request, we have to exit */
 			if (ssl->reqMinVer < ssl->minVer) {
@@ -1775,7 +1795,7 @@ SKIP_HSHEADER_PARSE:
 #endif
 				}
 #ifdef USE_TLS_1_2
-				if (compareMin == TLS_1_2_MIN_VER) {
+				if (compareMin >= TLS_1_2_MIN_VER) {
 					ssl->minVer = TLS_1_2_MIN_VER;
 					ssl->flags |= SSL_FLAGS_TLS_1_2 | SSL_FLAGS_TLS_1_1 | SSL_FLAGS_TLS;
 				}
@@ -1910,10 +1930,13 @@ SKIP_HSHEADER_PARSE:
 				psTraceInfo("Malformed clientHello message\n");
 				return MATRIXSSL_ERROR;
 			}
-#ifdef ENABLE_SECURE_REHANDSHAKES
+#ifdef ENABLE_SECURE_REHANDSHAKES || ENABLE_TLS_FALLBACK_SCSV
 /*
 			Below we stop looking after the first cipher we match but we need
 			to search for SCSV if secure rehandshakes are on and first conn
+
+			Also we need to check if the client provided TLS_FALLBACK_SCSV and
+			act accordingly if he did
 */
 			if (ssl->myVerifyDataLen == 0) {
 				extLen = 0; /* just overloading existing var */
@@ -1923,10 +1946,44 @@ SKIP_HSHEADER_PARSE:
 					if (cipher == TLS_EMPTY_RENEGOTIATION_INFO_SCSV) {
 						ssl->secureRenegotiationFlag = PS_TRUE;
 					}
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+					if (cipher == TLS_FALLBACK_SCSV) {
+/*						If the client supports TLS 1.1 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should NOT send the alert (the
+						protocol downgrade was set by us)
+
+						If the client supports TLS 1.0 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should send the alert
+*/
+						if ((forcedMin && (ssl->reqMinVer < ssl->minVer)) ||
+
+/*						If TLS version was not enforced by us, we compare to our highest
+						supported version
+*/
+#ifdef USE_TLS_1_2
+						(!forcedMin && (ssl->reqMinVer < TLS_1_2_MIN_VER))
+#else
+#ifdef USE_TLS_1_1
+						(!forcedMin && (ssl->reqMinVer < TLS_1_1_MIN_VER))
+#else
+						(!forcedMin && (ssl->reqMinVer < TLS_MIN_VER))
+#endif
+#endif
+						) {
+							ssl->err = SSL_ALERT_INAPPROPRIATE_FALLBACK;
+							psTraceInfo("FALLBACK_SCSV is specified and we can do better. Reject handshake");
+							return MATRIXSSL_ERROR;
+						}
+					}
+#endif /* ENABLED_TLS_FALLBACK_SCSV */
 				}
 			}
 #endif
 			p = c + suiteLen;
+
+			// Setup to find the stronget cipher the client supports
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 8; c++;
 				cipher += *c; c++;
@@ -1941,12 +1998,25 @@ SKIP_HSHEADER_PARSE:
 						break;
 					}
 				} else {
-					if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-						c = p;
-						break;
+					if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+						// Save the first cipher found - debuggin only
+						if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+
+						// Check if the current supported cipher index is lower than the best cipher index
+						// this means that we found a stroner cipher and we must save it
+						if (cipherIndex < bestCipherIndex) {
+							bestCipherIndex = cipherIndex;
+							ssl->cipher = foundCipher;
+							bestCipher = cipher;
+						}
 					}
 				}
 			}
+			
+			//if (firstCipherIndex != bestCipherIndex) psTraceInfo("Overriding client cipher preferences");
+
+			// Use the best cipher we found
+			if (cipherIndex > -1) cipher = bestCipher;
 /*
 			If we fell to the default cipher suite, we didn't have
 			any in common with the client, or the client is being bad
@@ -1955,7 +2025,7 @@ SKIP_HSHEADER_PARSE:
 			if (ssl->cipher == NULL || ssl->cipher->ident != cipher ||
 					cipher == SSL_NULL_WITH_NULL_NULL) {
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				return MATRIXSSL_ERROR;
 			}
@@ -2496,6 +2566,43 @@ SKIP_HSHEADER_PARSE:
 						}
 					}
 #endif
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+					if (extType == EXT_STATUS_REQUEST) {
+						/* Must hold 1 b status type, 2 b list len, 2 b list len */
+						if (extLen < 1 + 2 + 2) {
+							psTraceInfo("Invalid status request ext len\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+						}
+
+						if (*c == CERTIFICATE_STATUS_OCSP) {
+/*							For now OCSP staples are supported only if the client
+							doesn't send us responder IDs or OCSP extensions
+*/
+							if ((((int16) *(c + 1)) == 0) && (((int16) *(c + 3)) == 0)) {
+								/* Only respond if we have something to send */
+								if (ssl->status_request_DER_size > 0)
+									ssl->status_request = 1;
+							}
+						}
+					}
+#endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+					if (extType == EXT_SIGNED_CERTIFICATE_TIMESTAMP) {
+						/* Only respond if we have something to send */
+						if (ssl->SCT_size > 0)
+							ssl->SCT_request = 1;
+					}
+#endif
+
+/*
+psTraceIntInfo("extType = %d ", extType);
+psTraceIntInfo("extLen = %d\n", extLen);
+psTraceBytes(NULL, c, extLen);
+*/
+
 					c += extLen;
 				}
 			}
@@ -2652,18 +2759,30 @@ SKIP_HSHEADER_PARSE:
 			need to worry about matching resumed cipher suite.
 */
 			p = c + suiteLen;
+
+			// Prepare variables to detect best client supported cipher
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 16; c++;
 				cipher += *c << 8; c++;
 				cipher += *c; c++;
-				if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-					c = p;
-					break;
+				
+				if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+					if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+					if (cipherIndex < bestCipherIndex) {
+						bestCipherIndex = cipherIndex;
+						ssl->cipher = foundCipher;
+						bestCipher = cipher;
+					}
 				}
 			}
+
+			if (cipherIndex > -1) cipher = bestCipher;
+
 			if (ssl->cipher == NULL ||
 					ssl->cipher->ident == SSL_NULL_WITH_NULL_NULL) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceInfo("No matching cipher for SSL handshake\n");
 				return MATRIXSSL_ERROR;
@@ -3471,7 +3590,7 @@ PROTOCOL_DETERMINED:
 				if (memcmp(ssl->sessionId, c, sessionIdLen) == 0) {
 					ssl->flags |= SSL_FLAGS_RESUMED;
 				} else {
-					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL);
+					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 					memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3489,7 +3608,7 @@ PROTOCOL_DETERMINED:
 			c += sessionIdLen;
 		} else {
 			if (ssl->sessionIdLen > 0) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 				memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3524,7 +3643,7 @@ PROTOCOL_DETERMINED:
 				return MATRIXSSL_ERROR;
 			}
 		} else {
-			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) == NULL) {
+			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher, NULL)) == NULL) {
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
 				return MATRIXSSL_ERROR;

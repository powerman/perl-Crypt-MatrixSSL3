--- matrixssl-3-7-2b-open-original/matrixssl/matrixssl.c	2015-03-18 20:57:06.000000000 +0000
+++ matrixssl-3-7-2b-open/matrixssl/matrixssl.c	2016-03-27 16:07:02.000000000 +0000
@@ -56,7 +56,12 @@ static psMutex_t			g_sessTicketLock;
 #endif
 #endif /* USE_MULTITHREADING */
 
+#ifdef USE_SHARED_SESSION_CACHE
+sslSessionEntry_t		*sessionTable;
+#else
 static sslSessionEntry_t	sessionTable[SSL_SESSION_TABLE_SIZE];
+#endif
+
 static DLListEntry          sessionChronList;
 static void initSessionEntryChronList();
 #endif /* USE_SERVER_SIDE_SSL */
@@ -113,8 +118,19 @@ int32 matrixSslOpenWithConfig(char *conf
 	}
 #endif
 
-
 #ifdef USE_SERVER_SIDE_SSL
+
+#ifdef USE_SHARED_SESSION_CACHE
+	sessionTable = (sslSessionEntry_t *) mmap(NULL, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+
+	if (sessionTable == MAP_FAILED) {
+		psError("error creating shared memory\n");
+		return PS_FAILURE;
+	}
+
+	psTracePtrCore("sessionTable = %p\n", sessionTable);
+#endif
+
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
 
@@ -150,6 +166,11 @@ void matrixSslClose(void)
 	}
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+
+#ifdef USE_SHARED_SESSION_CACHE
+	munmap(sessionTable, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+#endif
+
 #ifdef USE_MULTITHREADING
 	psUnlockMutex(&sessionTableLock);
 	psDestroyMutex(&sessionTableLock);
@@ -1092,6 +1113,14 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 	lssl->nonceCtrLen = TLS_GCM_NONCE_LEN;
 #endif
 
+	
+/*	By default the session has access to all ciphers.
+	If we process an ALPN extension and the negociated application protocol if HTTP/2
+	the session will have access only to the ciphers not blacklisted in HTTP/2 specs.
+	https://http2.github.io/http2-spec/#BadCipherSuites
+*/
+	lssl->supportedCiphers = supportedCiphers_all;
+
 /*
 	Data buffers
 */
@@ -1117,7 +1146,7 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 
 	lssl->sPool = pool;
 	lssl->keys = (sslKeys_t*)keys;
-	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL);
+	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL, NULL);
 	sslActivateReadCipher(lssl);
 	sslActivateWriteCipher(lssl);
 
@@ -1298,7 +1327,7 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 
 		lssl->hsState = SSL_HS_SERVER_HELLO;
 		if (session != NULL && session->cipherId != SSL_NULL_WITH_NULL_NULL) {
-			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId);
+			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId, NULL);
 			if (lssl->cipher == NULL) {
 				psTraceInfo("Invalid session id to matrixSslNewSession\n");
 			} else {
@@ -1551,6 +1580,12 @@ void matrixSslDeleteSession(ssl_t *ssl)
 		psFree(ssl->alpn, ssl->sPool); ssl->alpn = NULL;
 	}
 #endif
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+	if ((ssl->status_request_DER_size > 0) && (ssl->status_request_DER_must_free))
+		psFree(ssl->status_request_DER, NULL);
+#endif
+
 /*
 	The cipher and mac contexts are inline in the ssl structure, so
 	clearing the structure clears those states as well.
@@ -2107,7 +2142,7 @@ int32 matrixServerSetKeysSNI(ssl_t *ssl,
 	if (ssl->sni_cb) {
 		ssl->extFlags.sni = 1; /* extension was actually handled */
 		keys = NULL;
-		(ssl->sni_cb)((void*)ssl, host, hostLen, &keys) ;
+		(ssl->sni_cb)((void *) ssl, host, hostLen, &keys, ssl->sni_cb_userPtr, ssl->sni_cb_ssl_id);
 		if (keys) {
 			ssl->keys = keys;
 			return 0;
@@ -2495,7 +2530,7 @@ int32 matrixUnlockSessionTicket(ssl_t *s
 	cipherSuite += *enc; enc++;
 
 	/* Force cipher suite */
-	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite)) == NULL) {
+	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite, NULL)) == NULL) {
 		psTraceInfo("Cipher suite check failure on session ticket\n");
 		return PS_FAILURE;
 	}

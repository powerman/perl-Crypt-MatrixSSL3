--- matrixssl-3-7-2b-open-original/matrixssl/matrixssl.c	2015-03-18 20:57:06.000000000 +0000
+++ matrixssl-3-7-2b-open/matrixssl/matrixssl.c	2016-03-30 16:42:37.000000000 +0000
@@ -56,7 +56,12 @@ static psMutex_t			g_sessTicketLock;
 #endif
 #endif /* USE_MULTITHREADING */
 
+#ifdef USE_SHARED_SESSION_CACHE
+sslSessionEntry_t		*sessionTable;
+#else
 static sslSessionEntry_t	sessionTable[SSL_SESSION_TABLE_SIZE];
+#endif
+
 static DLListEntry          sessionChronList;
 static void initSessionEntryChronList();
 #endif /* USE_SERVER_SIDE_SSL */
@@ -113,8 +118,19 @@ int32 matrixSslOpenWithConfig(char *conf
 	}
 #endif
 
-
 #ifdef USE_SERVER_SIDE_SSL
+
+#ifdef USE_SHARED_SESSION_CACHE
+	sessionTable = (sslSessionEntry_t *) mmap(NULL, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+
+	if (sessionTable == MAP_FAILED) {
+		psError("error creating shared memory\n");
+		return PS_FAILURE;
+	}
+
+	psTracePtrCore("sessionTable = %p\n", sessionTable);
+#endif
+
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
 
@@ -150,6 +166,11 @@ void matrixSslClose(void)
 	}
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+
+#ifdef USE_SHARED_SESSION_CACHE
+	munmap(sessionTable, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+#endif
+
 #ifdef USE_MULTITHREADING
 	psUnlockMutex(&sessionTableLock);
 	psDestroyMutex(&sessionTableLock);
@@ -1092,6 +1113,14 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 	lssl->nonceCtrLen = TLS_GCM_NONCE_LEN;
 #endif
 
+	
+/*	By default the session has access to all ciphers.
+	If we process an ALPN extension and the negociated application protocol if HTTP/2
+	the session will have access only to the ciphers not blacklisted in HTTP/2 specs.
+	https://http2.github.io/http2-spec/#BadCipherSuites
+*/
+	lssl->supportedCiphers = supportedCiphers_all;
+
 /*
 	Data buffers
 */
@@ -1117,7 +1146,7 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 
 	lssl->sPool = pool;
 	lssl->keys = (sslKeys_t*)keys;
-	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL);
+	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL, NULL);
 	sslActivateReadCipher(lssl);
 	sslActivateWriteCipher(lssl);
 
@@ -1298,7 +1327,7 @@ int32 matrixSslNewSession(ssl_t **ssl, c
 
 		lssl->hsState = SSL_HS_SERVER_HELLO;
 		if (session != NULL && session->cipherId != SSL_NULL_WITH_NULL_NULL) {
-			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId);
+			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId, NULL);
 			if (lssl->cipher == NULL) {
 				psTraceInfo("Invalid session id to matrixSslNewSession\n");
 			} else {
@@ -1551,6 +1580,12 @@ void matrixSslDeleteSession(ssl_t *ssl)
 		psFree(ssl->alpn, ssl->sPool); ssl->alpn = NULL;
 	}
 #endif
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+	if ((ssl->status_request_DER_size > 0) && (ssl->status_request_DER_must_free))
+		psFree(ssl->status_request_DER, NULL);
+#endif
+
 /*
 	The cipher and mac contexts are inline in the ssl structure, so
 	clearing the structure clears those states as well.
@@ -1992,6 +2027,8 @@ int32 matrixResumeSession(ssl_t *ssl)
 	unsigned char	*id;
 	uint32	i;
 
+	psTraceInfo("Trying to resume session\n");
+
 	if (!(ssl->flags & SSL_FLAGS_SERVER)) {
 		return PS_ARG_FAIL;
 	}
@@ -2015,6 +2052,9 @@ int32 matrixResumeSession(ssl_t *ssl)
 	Expiration is done on daily basis (86400 seconds)
 */
 	psGetTime(&accessTime, ssl->userPtr);
+
+	psTraceIntInfo("Session cache still ok for %d ms\n", SSL_SESSION_ENTRY_LIFE - psDiffMsecs(sessionTable[i].startTime, accessTime, ssl->userPtr));
+
 	if ((memcmp(sessionTable[i].id, id,
 			(uint32)min(ssl->sessionIdLen, SSL_MAX_SESSION_ID_SIZE)) != 0) ||
 			(psDiffMsecs(sessionTable[i].startTime,	accessTime, ssl->userPtr) >
@@ -2040,6 +2080,9 @@ int32 matrixResumeSession(ssl_t *ssl)
 #else /* PKCS11 TODO */
 	psTraceInfo("Session resumption not supported in PKCS#11\n");
 #endif
+
+	psTraceInfo("Session resumed\n");
+
 	return PS_SUCCESS;
 }
 
@@ -2107,7 +2150,7 @@ int32 matrixServerSetKeysSNI(ssl_t *ssl,
 	if (ssl->sni_cb) {
 		ssl->extFlags.sni = 1; /* extension was actually handled */
 		keys = NULL;
-		(ssl->sni_cb)((void*)ssl, host, hostLen, &keys) ;
+		(ssl->sni_cb)((void *) ssl, host, hostLen, &keys, ssl->sni_cb_userPtr, ssl->sni_cb_ssl_id);
 		if (keys) {
 			ssl->keys = keys;
 			return 0;
@@ -2495,11 +2538,13 @@ int32 matrixUnlockSessionTicket(ssl_t *s
 	cipherSuite += *enc; enc++;
 
 	/* Force cipher suite */
-	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite)) == NULL) {
+	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite, NULL)) == NULL) {
 		psTraceInfo("Cipher suite check failure on session ticket\n");
 		return PS_FAILURE;
 	}
 
+	psTraceIntInfo("Ticket using cipher %d\n", cipherSuite);
+
 	/* Set aside masterSecret */
 	memcpy(ssl->sid->masterSecret, enc, SSL_HS_MASTER_SIZE);
 	enc += SSL_HS_MASTER_SIZE;
@@ -2512,11 +2557,15 @@ int32 matrixUnlockSessionTicket(ssl_t *s
 
 	now = psGetTime(&t, ssl->userPtr);
 
+	psTraceIntInfo("Time = %d  ", time); psTraceIntInfo("Now = %d\n", now);
+	psTraceIntInfo("Session ticket still good for %d seconds\n", (SSL_SESSION_ENTRY_LIFE / 1000) - (now - time));
+
 	if ((now - time) > (SSL_SESSION_ENTRY_LIFE / 1000)) {
 		/* Expired session ticket.  New one will be issued */
 		psTraceInfo("Session ticket was expired\n");
 		return PS_FAILURE;
 	}
+
 	ssl->sid->cipherId = cipherSuite;
 
 	return PS_SUCCESS;

--- matrixssl-3-7-2b-open-original/matrixssl/sslDecode.c	2015-03-18 20:57:06.000000000 +0000
+++ matrixssl-3-7-2b-open/matrixssl/sslDecode.c	2016-03-27 16:18:47.000000000 +0000
@@ -1320,11 +1320,18 @@ static int32 addCompressCount(ssl_t *ssl
 */
 static int32 parseSSLHandshake(ssl_t *ssl, char *inbuf, uint32 len)
 {
-	unsigned char	*c, *end;
+	unsigned char	*c, *tmp_c, *end;
 	unsigned char	hsType;
+	// variables used when walking through client provided cipher list
+	// all indexes are relative to our supportedCiphers list (see cipherSuite.c)
+	//   cipherIndex is the current tested cipher
+	//   bestCipherIndex is the strongest cipher according to our list
+	//   firstCipherIndex is the first cipher in the client's list
+	int16	 cipherIndex, bestCipherIndex, firstCipherIndex;
 	int32			rc, i = 0;
+	sslCipherSpec_t	*foundCipher;
 	short			renegotiationExt;
-	uint32			hsLen, extLen, extType, cipher = 0;
+	uint32			hsLen, extLen, extType, cipher = 0, bestCipher = 0;
 	unsigned char	hsMsgHash[SHA384_HASH_SIZE];
 	void			*pkiData = ssl->userPtr;
 
@@ -1416,6 +1423,14 @@ static int32 parseSSLHandshake(ssl_t *ss
 #endif /* SERVER && USE_ECC_CIPHER_SUITE */
 
 
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+/*	Remember if we forced a downgrade so we know which versions to compare
+		and we don't reject the handshake if TLS_FALLBACK_SCSV is specified.
+*/
+		int16 forcedMin = 0;
+#endif
+
+
 	rc = MATRIXSSL_SUCCESS;
 	c = (unsigned char*)inbuf;
 	end = (unsigned char*)(inbuf + len);
@@ -1741,7 +1756,12 @@ SKIP_HSHEADER_PARSE:
 		Client should always be sending highest supported protocol.  Server
 		will reply with a match or a lower version if enabled (or forced).
 */
+
+
 		if (ssl->majVer != 0) {
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+			forcedMin = 1;
+#endif
 			/* If our forced server version is a later protocol than their
 				request, we have to exit */
 			if (ssl->reqMinVer < ssl->minVer) {
@@ -1775,7 +1795,7 @@ SKIP_HSHEADER_PARSE:
 #endif
 				}
 #ifdef USE_TLS_1_2
-				if (compareMin == TLS_1_2_MIN_VER) {
+				if (compareMin >= TLS_1_2_MIN_VER) {
 					ssl->minVer = TLS_1_2_MIN_VER;
 					ssl->flags |= SSL_FLAGS_TLS_1_2 | SSL_FLAGS_TLS_1_1 | SSL_FLAGS_TLS;
 				}
@@ -1910,10 +1930,13 @@ SKIP_HSHEADER_PARSE:
 				psTraceInfo("Malformed clientHello message\n");
 				return MATRIXSSL_ERROR;
 			}
-#ifdef ENABLE_SECURE_REHANDSHAKES
+#if defined(ENABLE_SECURE_REHANDSHAKES) || defined(ENABLE_TLS_FALLBACK_SCSV)
 /*
 			Below we stop looking after the first cipher we match but we need
 			to search for SCSV if secure rehandshakes are on and first conn
+
+			Also we need to check if the client provided TLS_FALLBACK_SCSV and
+			act accordingly if he did
 */
 			if (ssl->myVerifyDataLen == 0) {
 				extLen = 0; /* just overloading existing var */
@@ -1923,10 +1946,189 @@ SKIP_HSHEADER_PARSE:
 					if (cipher == TLS_EMPTY_RENEGOTIATION_INFO_SCSV) {
 						ssl->secureRenegotiationFlag = PS_TRUE;
 					}
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+					if (cipher == TLS_FALLBACK_SCSV) {
+/*						If the client supports TLS 1.1 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should NOT send the alert (the
+						protocol downgrade was set by us)
+
+						If the client supports TLS 1.0 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should send the alert
+*/
+						if ((forcedMin && (ssl->reqMinVer < ssl->minVer)) ||
+
+/*						If TLS version was not enforced by us, we compare to our highest
+						supported version
+*/
+#ifdef USE_TLS_1_2
+						(!forcedMin && (ssl->reqMinVer < TLS_1_2_MIN_VER))
+#else
+#ifdef USE_TLS_1_1
+						(!forcedMin && (ssl->reqMinVer < TLS_1_1_MIN_VER))
+#else
+						(!forcedMin && (ssl->reqMinVer < TLS_MIN_VER))
+#endif
+#endif
+						) {
+							ssl->err = SSL_ALERT_INAPPROPRIATE_FALLBACK;
+							psTraceInfo("FALLBACK_SCSV is specified and we can do better. Reject handshake");
+							return MATRIXSSL_ERROR;
+						}
+					}
+#endif /* ENABLED_TLS_FALLBACK_SCSV */
 				}
 			}
 #endif
+
+/*			Save current progress because before doing anything else we need to look
+			for SNI and ALPN extensions.
+			We look for SNI because virtual hosts may implement different protocols
+			and this will affect how the ALPN extension is handled.
+			We look for ALPN because if the selected protocol is HTTP/2 we will only
+			be able to use ciphers that are not blacklisted.
+*/
+			tmp_c = c;
+
+			c+= suiteLen;
+
+/*
+			Compression parameters
+			Overloading extLen in this section
+*/
+			if (end - c < 1) {
+				ssl->err = SSL_ALERT_DECODE_ERROR;
+				psTraceInfo("Invalid compression header length\n");
+				return MATRIXSSL_ERROR;
+			}
+			extLen = *c++;
+			if ((uint32)(end - c) < extLen) {
+				ssl->err = SSL_ALERT_DECODE_ERROR;
+				psTraceInfo("Invalid compression header length\n");
+				return MATRIXSSL_ERROR;
+			}
+			c += extLen;
+
+			if (c != end) {
+				if (end - c < 2) {
+					ssl->err = SSL_ALERT_DECODE_ERROR;
+					psTraceInfo("Invalid extension header len\n");
+					return MATRIXSSL_ERROR;
+				}
+				extLen = *c << 8; c++; /* Total length of list */
+				extLen += *c; c++;
+				/* extLen must be minimum 2 b type 2 b len and 0 b value */
+				if ((uint32)(end - c) < extLen || extLen < 4) {
+					ssl->err = SSL_ALERT_DECODE_ERROR;
+					psTraceInfo("Invalid extension header len\n");
+					return MATRIXSSL_ERROR;
+				}
+				while (c != end) {
+					extType = *c << 8; c++; /* Individual hello ext */
+					extType += *c; c++;
+					if (end - c < 2) {
+						ssl->err = SSL_ALERT_DECODE_ERROR;
+						psTraceInfo("Invalid extension header len\n");
+						return MATRIXSSL_ERROR;
+					}
+					extLen = *c << 8; c++; /* length of one extension */
+					extLen += *c; c++;
+					/* Minimum extension value len is 0 bytes */
+					if ((uint32)(end - c) < extLen) {
+						ssl->err = SSL_ALERT_DECODE_ERROR;
+						psTraceInfo("Invalid extension header len\n");
+						return MATRIXSSL_ERROR;
+					}
+#ifdef MATRIX_DEBUG
+					psTraceIntInfo("Ext type before cipher selection = %d\n", extType);
+#endif
+
+					if (extType == EXT_SNI) {
+#ifdef MATRIX_DEBUG
+						psTraceInfo("Handling SNI extension before selecting cipher");
+#endif
+						/* Must hold 2 b len 1 b zero 2 b len */
+						if (extLen < 3 + 2) {
+							psTraceInfo("Invalid server name ext len\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+						}
+						/* Two length bytes.  May seem odd to ignore but
+							the inner length is repeated right below after
+							the expected 0x0 bytes */
+						i = *c << 8; c++;
+						i += *c; c++;
+						if (*c++ != 0x0) {
+							psTraceInfo("Expected host_name in SNI ext\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+
+						}
+						extLen -= 3;
+						i = *c << 8; c++;
+						i += *c; c++;
+						extLen -= 2;	/* Length check covered above */
+						/* Arbitrary length cap between 1 and min(extlen,255) */
+						if ((int32)extLen < i || i > 255 || i <= 0) {
+							psTraceInfo("Invalid host name ext len\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+						}
+						extLen -= i;
+						if (matrixServerSetKeysSNI(ssl, (char*)c, i) < 0) {
+							psTraceInfo("Server didn't load SNI keys\n");
+							ssl->err = SSL_ALERT_UNRECOGNIZED_NAME;
+							return MATRIXSSL_ERROR;
+						}
+						c += i;
+					}
+#ifdef USE_ALPN
+					if (extType == EXT_ALPN) {
+#ifdef MATRIX_DEBUG
+						psTraceInfo("Handling ALPN before selecting cipher\n");
+#endif
+						/* Must hold 2 b len 1 b zero 2 b len */
+						if (extLen < 2) {
+							psTraceInfo("Invalid ALPN ext len\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+						}
+						/* Skip extension if server didn't register callback */
+						if (ssl->srv_alpn_cb) {
+							if ((rc = dealWithAlpnExt(ssl, c, extLen)) < 0) {
+								if (rc == PS_PROTOCOL_FAIL) {
+									/* This is a user space rejection */
+									psTraceInfo("User rejects ALPN ext\n");
+									ssl->err = SSL_ALERT_NO_APP_PROTOCOL;
+									return MATRIXSSL_ERROR;
+								} else if (rc == PS_ARG_FAIL) {
+									/* HTTP/2 selection with TLS < 1.2 */
+									psTraceInfo("HTTP/2 selection with TLS < 1.2\n");
+									ssl->err = SSL_ALERT_INSUFFICIENT_SECURITY;
+									return MATRIXSSL_ERROR;
+								}
+								psTraceInfo("Invalid ALPN ext\n");
+								ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+								return MATRIXSSL_ERROR;
+							}
+						}
+					}
+#endif
+					c += extLen;
+				}
+			}
+
+/*			Now that we handled SNI and ALPN extensions we resume where we left */
+			c = tmp_c;
+
+/*          Select best cipher (if HTTP/2 was selected the ciphers list is replaced)
+			with supportedCiphers_http2
+*/
+
 			p = c + suiteLen;
+
+			// Setup to find the stronget cipher the client supports
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 8; c++;
 				cipher += *c; c++;
@@ -1941,12 +2143,30 @@ SKIP_HSHEADER_PARSE:
 						break;
 					}
 				} else {
-					if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-						c = p;
-						break;
+					if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+						// Save the first cipher found - debuggin only
+						if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+
+						// Check if the current supported cipher index is lower than the best cipher index
+						// this means that we found a stroner cipher and we must save it
+						if (cipherIndex < bestCipherIndex) {
+							bestCipherIndex = cipherIndex;
+							ssl->cipher = foundCipher;
+							bestCipher = cipher;
+						}
 					}
 				}
 			}
+			
+#ifdef MATRIX_DEBUG
+			if (bestCipherIndex != 32767) {
+				if (firstCipherIndex != bestCipherIndex) psTraceInfo("Overriding client cipher preferences\n");
+				psTraceIntInfo("firstCipherIndex = %d\n", firstCipherIndex);
+				psTraceIntInfo("bestCipherIndex = %d\n", bestCipherIndex);
+			}
+#endif
+			// Use the best cipher we found
+			if (cipherIndex > -1) cipher = bestCipher;
 /*
 			If we fell to the default cipher suite, we didn't have
 			any in common with the client, or the client is being bad
@@ -1955,7 +2175,7 @@ SKIP_HSHEADER_PARSE:
 			if (ssl->cipher == NULL || ssl->cipher->ident != cipher ||
 					cipher == SSL_NULL_WITH_NULL_NULL) {
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				return MATRIXSSL_ERROR;
 			}
@@ -2051,6 +2271,10 @@ SKIP_HSHEADER_PARSE:
 						psTraceInfo("Invalid extension header len\n");
 						return MATRIXSSL_ERROR;
 					}
+#ifdef MATRIX_DEBUG
+					psTraceIntInfo("Ext type = %d\n", extType);
+#endif
+
 #ifdef ENABLE_SECURE_REHANDSHAKES
 /*
 					Handle incoming client extensions we support.
@@ -2436,66 +2660,36 @@ SKIP_HSHEADER_PARSE:
 						}
 						c++; extLen--;
 					}
-					if (extType == EXT_SNI) {
-						/* Must hold 2 b len 1 b zero 2 b len */
-						if (extLen < 3 + 2) {
-							psTraceInfo("Invalid server name ext len\n");
-							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
-							return MATRIXSSL_ERROR;
-						}
-						/* Two length bytes.  May seem odd to ignore but
-							the inner length is repeated right below after
-							the expected 0x0 bytes */
-						i = *c << 8; c++;
-						i += *c; c++;
-						if (*c++ != 0x0) {
-							psTraceInfo("Expected host_name in SNI ext\n");
-							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
-							return MATRIXSSL_ERROR;
 
-						}
-						extLen -= 3;
-						i = *c << 8; c++;
-						i += *c; c++;
-						extLen -= 2;	/* Length check covered above */
-						/* Arbitrary length cap between 1 and min(extlen,255) */
-						if ((int32)extLen < i || i > 255 || i <= 0) {
-							psTraceInfo("Invalid host name ext len\n");
-							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
-							return MATRIXSSL_ERROR;
-						}
-						extLen -= i;
-						if (matrixServerSetKeysSNI(ssl, (char*)c, i) < 0) {
-							psTraceInfo("Server didn't load SNI keys\n");
-							ssl->err = SSL_ALERT_UNRECOGNIZED_NAME;
-							return MATRIXSSL_ERROR;
-						}
-						c += i;
-					}
-#ifdef USE_ALPN
-					if (extType == EXT_ALPN) {
-						/* Must hold 2 b len 1 b zero 2 b len */
-						if (extLen < 2) {
-							psTraceInfo("Invalid ALPN ext len\n");
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+					if (extType == EXT_STATUS_REQUEST) {
+						/* Must hold 1 b status type, 2 b list len, 2 b list len */
+						if (extLen < 1 + 2 + 2) {
+							psTraceInfo("Invalid status request ext len\n");
 							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
 							return MATRIXSSL_ERROR;
 						}
-						/* Skip extension if server didn't register callback */
-						if (ssl->srv_alpn_cb) {
-							if ((rc = dealWithAlpnExt(ssl, c, extLen)) < 0) {
-								if (rc == PS_PROTOCOL_FAIL) {
-									/* This is a user space rejection */
-									psTraceInfo("User rejects ALPN ext\n");
-									ssl->err = SSL_ALERT_NO_APP_PROTOCOL;
-									return MATRIXSSL_ERROR;
-								}
-								psTraceInfo("Invalid ALPN ext\n");
-								ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
-								return MATRIXSSL_ERROR;
+
+						if (*c == CERTIFICATE_STATUS_OCSP) {
+/*							For now OCSP staples are supported only if the client
+							doesn't send us responder IDs or OCSP extensions
+*/
+							if ((((int16) *(c + 1)) == 0) && (((int16) *(c + 3)) == 0)) {
+								/* Only respond if we have something to send */
+								if (ssl->status_request_DER_size > 0)
+									ssl->status_request = 1;
 							}
 						}
 					}
 #endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+					if (extType == EXT_SIGNED_CERTIFICATE_TIMESTAMP) {
+						/* Only respond if we have something to send */
+						if (ssl->SCT_size > 0)
+							ssl->SCT_request = 1;
+					}
+#endif
 					c += extLen;
 				}
 			}
@@ -2652,18 +2846,30 @@ SKIP_HSHEADER_PARSE:
 			need to worry about matching resumed cipher suite.
 */
 			p = c + suiteLen;
+
+			// Prepare variables to detect best client supported cipher
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 16; c++;
 				cipher += *c << 8; c++;
 				cipher += *c; c++;
-				if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-					c = p;
-					break;
+				
+				if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+					if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+					if (cipherIndex < bestCipherIndex) {
+						bestCipherIndex = cipherIndex;
+						ssl->cipher = foundCipher;
+						bestCipher = cipher;
+					}
 				}
 			}
+
+			if (cipherIndex > -1) cipher = bestCipher;
+
 			if (ssl->cipher == NULL ||
 					ssl->cipher->ident == SSL_NULL_WITH_NULL_NULL) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceInfo("No matching cipher for SSL handshake\n");
 				return MATRIXSSL_ERROR;
@@ -3471,7 +3677,7 @@ PROTOCOL_DETERMINED:
 				if (memcmp(ssl->sessionId, c, sessionIdLen) == 0) {
 					ssl->flags |= SSL_FLAGS_RESUMED;
 				} else {
-					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL);
+					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 					memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3489,7 +3695,7 @@ PROTOCOL_DETERMINED:
 			c += sessionIdLen;
 		} else {
 			if (ssl->sessionIdLen > 0) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 				memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3524,7 +3730,7 @@ PROTOCOL_DETERMINED:
 				return MATRIXSSL_ERROR;
 			}
 		} else {
-			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) == NULL) {
+			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher, NULL)) == NULL) {
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
 				return MATRIXSSL_ERROR;
@@ -5258,7 +5464,7 @@ static int32 dealWithAlpnExt(ssl_t *ssl,
 	userChoice = MAX_PROTO_EXT;
 
 	/* Already tested if callback exists */
-	(*ssl->srv_alpn_cb)((void*)ssl, (short)i, proto, protoLen, &userChoice);
+	(*ssl->srv_alpn_cb)((void*)ssl, (short)i, proto, protoLen, &userChoice, ssl->srv_alpn_cb_userPtr, ssl->srv_alpn_cb_ssl_id);
 
 	if (userChoice == MAX_PROTO_EXT) {
 		/* User chose to completely ignore. No reply extension will be sent */
@@ -5292,6 +5498,10 @@ static int32 dealWithAlpnExt(ssl_t *ssl,
 	ssl->alpn = proto[userChoice];
 	ssl->alpnLen = protoLen[userChoice];
 
+#ifdef MATRIX_DEBUG
+	_psTraceStr("ALPN: Protocol selected: %.*s\n", ssl->alpnLen, ssl->alpn);
+#endif
+
 	while (i > 0) {
 		if (i - 1 != userChoice) {
 			psFree(proto[i - 1], ssl->sPool);
@@ -5299,6 +5509,23 @@ static int32 dealWithAlpnExt(ssl_t *ssl,
 		i--;
 	}
 
+	if ((ssl->alpnLen == 2) && !strncmp(ssl->alpn, "h2", 2)) {
+#ifdef MATRIX_DEBUG
+		psTraceInfo("ALPN: For protocol HTTP/2 we must enforce TLS 1.2 and use approved cipher suites\n");
+		psTraceIntInfo("ssl->minVer: %d\n", ssl->minVer);
+		psTraceIntInfo("ssl->majVer: %d\n", ssl->majVer);
+		psTraceIntInfo("ssl->reqMinVer: %d\n", ssl->reqMinVer);
+		psTraceIntInfo("ssl->reqMajVer: %d\n", ssl->reqMajVer);
+#endif
+
+		if (ssl->minVer < TLS_1_2_MIN_VER) {
+			return PS_ARG_FAIL;
+		}
+
+		// only using HTTP/2 approved ciphers
+		ssl->supportedCiphers = supportedCiphers_http2;
+	}
+
 	return PS_SUCCESS;
 }
 #endif /* USE_ALPN && USE_SERVER_SIDE_SSL */

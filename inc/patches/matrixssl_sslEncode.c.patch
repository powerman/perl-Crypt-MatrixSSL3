--- matrixssl-3-7-2b-open-original/matrixssl/sslEncode.c	2015-07-07 00:03:28.000000000 +0000
+++ matrixssl-3-7-2b-open/matrixssl/sslEncode.c	2016-03-23 22:32:46.000000000 +0000
@@ -39,6 +39,10 @@
 #ifndef USE_ONLY_PSK_CIPHER_SUITE
 static int32 writeCertificate(ssl_t *ssl, sslBuf_t *out, int32 notEmpty);
 #endif
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+#endif
 static int32 writeChangeCipherSpec(ssl_t *ssl, sslBuf_t *out);
 static int32 writeFinished(ssl_t *ssl, sslBuf_t *out);
 static int32 writeAlert(ssl_t *ssl, unsigned char level,
@@ -1185,7 +1189,25 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 		}
 #endif /* USE_DHE_CIPHER_SUITE */
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+/*
+		If the client send a "status request" extension we will respond with
+		a CERTIFICATE_STATUS message
+
+		Add our requirements to the final message size
+*/
+		if (ssl->status_request) {
+		    // 1 byte for the status type, 3 bytes for the OCSP DER staple
+		    messageSize += ssl->recordHeadLen + ssl->hshakeHeadLen + 1 + 3;
+
+		    // Test if DER size is too large and we need fragmentation
+		    if (ssl->status_request_DER_size > ssl->maxPtFrag)
+			messageSize += addCertFragOverhead(ssl, ssl->status_request_DER_size);
 
+		    messageSize += ssl->status_request_DER_size;
+		    messageSize += secureWriteAdditions(ssl, 1);
+		}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 /*
 		Add extensions
 */
@@ -1219,6 +1241,19 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 		}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+		if (ssl->status_request) {
+			extSize = 2;
+			messageSize += 4;
+		}
+#endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+		if (ssl->SCT_request) {
+			extSize = 2;
+			messageSize += 2 + 2 + 2 + ssl->SCT_size; /* 2 type, 2 length, data */
+		}
+#endif
 
 #ifdef ENABLE_SECURE_REHANDSHAKES
 /*
@@ -1249,12 +1284,14 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 /*
 		Done with extensions.  If had some, add the two byte total length
 */
+
 		messageSize += extSize;
 
 		if ((out->buf + out->size) - out->end < messageSize) {
 			*requiredLen = messageSize;
 			return SSL_FULL;
 		}
+
 /*
 		Message size complete.  Begin the flight write
 */
@@ -1268,6 +1305,12 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writeCertificate(ssl, out, 1);
 				}
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 			}
 
 #endif /* !USE_ONLY_PSK_CIPHER_SUITE */
@@ -1289,6 +1332,12 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 #endif /* USE_DHE_CIPHER_SUITE */
 #ifdef USE_PSK_CIPHER_SUITE
 			if (ssl->flags & SSL_FLAGS_PSK_CIPHER) {
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writePskServerKeyExchange(ssl, out);
 				}
@@ -1298,6 +1347,12 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writeCertificate(ssl, out, 1);
 				}
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 #endif /* !USE_ONLY_PSK_CIPHER_SUITE */
 #ifdef USE_PSK_CIPHER_SUITE
 			}
@@ -1320,7 +1375,7 @@ int32 sslEncodeResponse(ssl_t *ssl, psBu
 			rc = writeServerHelloDone(ssl, out);
 		}
 		if (rc == SSL_FULL) {
-			psTraceInfo("Bad flight messageSize calculation");
+			psTraceInfo("Bad flight messageSize calculation\n");
 			ssl->err = SSL_ALERT_INTERNAL_ERROR;
 			out->end = out->start;
 			alertReqLen = out->size;
@@ -2796,6 +2851,29 @@ static int32 writeServerHello(ssl_t *ssl
 	}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+/*
+	If the client sent a "status request" extension we must respond by adding
+	an empty "status request" extension ourselfs and by sending a
+	CERTIFICATE_STATUS message
+*/
+	if (ssl->status_request) {
+		if (extLen == 0) {
+			extLen = 2;
+		}
+		extLen += 4; /* 2 type, 2 len = 0 */
+	}
+#endif ENABLE_CERTIFICATE_STATUS_REQUEST
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+	if (ssl->SCT_request) {
+		if (extLen == 0) {
+			extLen = 2;
+		}
+		extLen += 2 + 2 + 2 + ssl->SCT_size; /* 2 type, 2 len, data */
+	}
+#endif
+
 	messageSize += extLen;
 
 /*
@@ -2936,6 +3014,29 @@ static int32 writeServerHello(ssl_t *ssl
 		}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+		// add our empty "status request" extension if the client sent us one
+		if (ssl->status_request) {
+			*c = (EXT_STATUS_REQUEST & 0xFF00) >> 8; c++;
+			*c = EXT_STATUS_REQUEST & 0xFF; c++;
+			*c = 0; c++;
+			*c = 0; c++;
+		}
+#endif ENABLE_CERTIFICATE_STATUS_REQUEST
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+		if (ssl->SCT_request) {
+			*c = (EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF00) >> 8; c++;
+			*c = EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF; c++;
+			*c = ((ssl->SCT_size + 2) & 0xFF00) >> 8; c++;
+			*c = (ssl->SCT_size + 2) & 0xFF; c++;
+			*c = (ssl->SCT_size & 0xFF00) >> 8; c++;
+			*c = ssl->SCT_size & 0xFF; c++;
+			memcpy(c, ssl->SCT, ssl->SCT_size);
+			c += ssl->SCT_size;
+		}
+#endif
+
 #ifdef ENABLE_SECURE_REHANDSHAKES
 		if (ssl->secureRenegotiationFlag == PS_TRUE) {
 			/* RenegotiationInfo*/
@@ -3757,6 +3858,7 @@ static int32 writeMultiRecordCertificate
 }
 #endif /* USE_SERVER_SIDE_SSL || USE_CLIENT_AUTH */
 
+
 /******************************************************************************/
 /*
 	Write a Certificate message.
@@ -3881,6 +3983,218 @@ static int32 writeCertificate(ssl_t *ssl
 	}
 	return MATRIXSSL_SUCCESS;
 }
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+
+/*
+	A fragmented write of the CERTIFICATE_STATUS handhshake message.  This is one
+	of the handshake messages that supports fragmentation because it is one of the
+	messages where the 512byte plaintext max of the max_fragment extension can
+	be exceeded.
+*/
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+	unsigned char *DER;
+	unsigned char	*c, *end, *encryptStart;
+	char			padLen;
+	int32			messageSize, rc, DERLen;
+	int32			midWrite, midSizeWrite, countDown, firstOne = 1;
+	int32 lsize;
+
+	c = out->end;
+	end = out->buf + out->size;
+
+	midSizeWrite = midWrite = 0;
+	DER = ssl->status_request_DER;
+	DERLen = ssl->status_request_DER_size;
+	
+	lsize = 1 + 3; // 1 byte OCSP status type + 3 bytes DER length;
+
+	while (DERLen > 0) {
+		if (firstOne) {
+			firstOne = 0;
+			countDown = ssl->maxPtFrag;
+
+			messageSize = DERLen + lsize + ssl->recordHeadLen + ssl->hshakeHeadLen;
+			if ((rc = writeRecordHeader(ssl,
+					SSL_RECORD_TYPE_HANDSHAKE_FIRST_FRAG, SSL_HS_CERTIFICATE_STATUS,
+					&messageSize, &padLen, &encryptStart, &end, &c)) < 0) {
+				return rc;
+			}
+			
+			// Write the status type
+			*c = CERTIFICATE_STATUS_OCSP; c++;
+			
+			// Account for what has been written so far
+			countDown -= ssl->hshakeHeadLen + 1;
+
+			midWrite = 0;
+			if (countDown < 3) {
+				/* Fragment falls right on DER len write.  Has
+					to be at least one byte or countDown would have
+					been 0 and got us out of here already*/
+				*c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+				c++; countDown--;
+				midSizeWrite = 2;
+				if (countDown != 0) {
+					*c = (DERLen & 0xFF00) >> 8; c++; countDown--;
+					midSizeWrite = 1;
+					if (countDown != 0) {
+						*c = (DERLen & 0xFF); c++; countDown--;
+						midSizeWrite = 0;
+					}
+				}
+				goto postpone_and_next;
+			} else {
+				*c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+				c++;
+				*c = (DERLen & 0xFF00) >> 8; c++;
+				*c = (DERLen & 0xFF); c++;
+				countDown -= 3;
+			}
+			midWrite = min(DERLen, countDown);
+			memcpy(c, DER, midWrite);
+			DERLen -= midWrite;
+			c += midWrite;
+			countDown -= midWrite;
+			
+			postpone_and_next:
+			if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+					SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+					&c)) < 0) {
+				return rc;
+			}
+
+			out->end = c;
+		} else {
+/*
+			Not-first fragments
+*/
+			if (midSizeWrite > 0) {
+				messageSize = midSizeWrite;
+			} else {
+				messageSize = 0;
+			}
+			if ((DERLen + messageSize) > ssl->maxPtFrag) {
+				messageSize += ssl->maxPtFrag;
+			} else {
+				messageSize += DERLen;
+			}
+
+			countDown = messageSize;
+			messageSize += ssl->recordHeadLen;
+			/* Second, etc... */
+			if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE_FRAG,
+					SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+					&end, &c)) < 0) {
+				return rc;
+			}
+
+			if (midSizeWrite > 0) {
+				if (midSizeWrite == 2) {
+					*c = (DERLen & 0xFF00) >> 8; c++;
+					*c = (DERLen & 0xFF); c++;
+					countDown -= 2;
+				} else {
+					*c = (DERLen & 0xFF); c++;
+					countDown -= 1;
+				}
+				midSizeWrite = 0;
+			}
+
+			if (countDown < DERLen) {
+				memcpy(c, DER + midWrite, countDown);
+				DERLen -= countDown;
+				c += countDown;
+				midWrite += countDown;
+				countDown = 0;
+			} else {
+				memcpy(c, DER + midWrite, DERLen);
+				c += DERLen;
+				countDown -= DERLen;
+				DERLen -= DERLen;
+			}
+
+			if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+					SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+					&c)) < 0) {
+				return rc;
+			}
+			out->end = c;
+		}
+	}
+
+	out->end = c;
+	return MATRIXSSL_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	Write a Certificate Status message.
+	The encoding of the message is as follows:
+		1 byte status type
+		3 byte length of DER data (network byte order)
+		x bytes DER data
+*/
+
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+	unsigned char *DER;
+	uint32			DERLen;
+
+	unsigned char	*c, *end, *encryptStart;
+	char			padLen;
+	int32			lsize, messageSize, i, rc;
+
+	psTraceHs("<<< server creating CERTIFICATE_STATUS  message\n");
+
+	c = out->end;
+	end = out->buf + out->size;
+
+	DERLen = ssl->status_request_DER_size;
+	lsize = 1 + 3;  // 1 byte status type + 3 bytes DER length
+
+	/* TODO DTLS: Make sure this maxPtFrag is consistent with the fragment
+		extension and is not interfering with DTLS notions of fragmentation */
+	if ((DERLen + lsize + ssl->hshakeHeadLen) > ssl->maxPtFrag) {
+		return writeMultiRecordCertificateStatus(ssl, out);
+	} else {
+		messageSize =
+			ssl->recordHeadLen +
+			ssl->hshakeHeadLen +
+			lsize + DERLen;
+
+		if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+				SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+				&end, &c)) < 0) {
+			return rc;
+		}
+
+		// Write out status type
+		*c = CERTIFICATE_STATUS_OCSP; c++;
+
+		// Write out DER length and DER
+		DER = ssl->status_request_DER;
+		if (DERLen > 0) {
+			*c = (unsigned char)((DERLen & 0xFF0000) >> 16); c++;
+			*c = (DERLen & 0xFF00) >> 8; c++;
+			*c = (DERLen & 0xFF); c++;
+			memcpy(c, DER, DERLen);
+			c += DERLen;
+		}
+
+		if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+				SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+				&c)) < 0) {
+			return rc;
+		}
+		out->end = c;
+	}
+	return MATRIXSSL_SUCCESS;
+}
+
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
+
 #endif /* USE_ONLY_PSK_CIPHER_SUITE */
 
 /******************************************************************************/
@@ -4097,7 +4411,7 @@ int32 matrixSslEncodeClientHello(ssl_t *
 		/* If ciphers are specified it is two bytes length and two bytes data */
 		cipherLen = 2;
 		for (i = 0; i < cipherSpecLen; i++) {
-			if ((cipherDetails = sslGetCipherSpec(ssl, cipherSpecs[i]))
+			if ((cipherDetails = sslGetCipherSpec(ssl, cipherSpecs[i], NULL))
 					== NULL) {
 				psTraceIntInfo("Cipher suite not supported: %d\n",
 					cipherSpecs[i]);

diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/coreApi.h matrixssl-3-7-2b-open/core/coreApi.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/coreApi.h	2015-03-18 13:57:08.000000000 -0700
+++ matrixssl-3-7-2b-open/core/coreApi.h	2016-02-11 11:42:41.000000000 -0800
@@ -40,6 +40,11 @@
 #include "list.h"
 #include "psmalloc.h"
 
+#ifdef USE_SHARED_SESSION_CACHE
+#include <sys/mman.h>
+#include <fcntl.h>
+#endif
+
 /******************************************************************************/
 /*
 	psCore return codes
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/coreConfig.h matrixssl-3-7-2b-open/core/coreConfig.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/coreConfig.h	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/core/coreConfig.h	2016-02-11 11:42:41.000000000 -0800
@@ -50,7 +50,6 @@
 */
 /* #define USE_CORE_TRACE */
 
-
 /******************************************************************************/
 /*
 	Include the osdepMutex family of APIs
@@ -59,6 +58,17 @@
 
 /******************************************************************************/
 /*
+  Share the session cache between processes - note that this is using annonymous
+  shared memory - so the memory will be available only between fork'ed processes
+*/
+/* #define USE_SHARED_SESSION_CACHE */
+
+#if defined(USE_SHARED_SESSION_CACHE) && !defined(USE_MULTITHREADING)
+#error USE_MULTITHREADING must be enabled when using shared session cache (synchronization mechanism)
+#endif
+
+/******************************************************************************/
+/*
 	Use C_GenerateRandom for entropy gathering
 */
 /* #define USE_PKCS11_ENTROPY */
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/osdep.h matrixssl-3-7-2b-open/core/osdep.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/osdep.h	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/core/osdep.h	2016-02-11 11:42:41.000000000 -0800
@@ -128,9 +128,9 @@
 
 #ifdef WIN32
  #ifndef _USRDLL
-  #define PSPUBLIC extern __declspec(dllimport)
+  #define PSPUBLIC extern
  #else
-  #define PSPUBLIC extern __declspec(dllexport)
+  #define PSPUBLIC extern
  #endif
 #else
  #define PSPUBLIC extern
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/POSIX/osdep.c matrixssl-3-7-2b-open/core/POSIX/osdep.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/core/POSIX/osdep.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/core/POSIX/osdep.c	2016-02-11 11:42:41.000000000 -0800
@@ -250,6 +250,15 @@
 		psErrorInt("pthread_mutexattr_init failed %d\n", rc);
 		return PS_PLATFORM_FAIL;
 	}
+
+#ifdef USE_SHARED_SESSION_CACHE
+	// make the mutex process shareable
+	if ((rc = pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED)) < 0) {
+		psErrorInt("pthread_mutexattr_setpshared failed %d\n", rc);
+		return PS_PLATFORM_FAIL;
+	}
+#endif
+
 	return PS_SUCCESS;
 }
 
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/cryptoConfig.h matrixssl-3-7-2b-open/crypto/cryptoConfig.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/cryptoConfig.h	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/cryptoConfig.h	2016-02-11 11:42:41.000000000 -0800
@@ -202,7 +202,19 @@
 /* @security Zero the stack of functions operating on secret data */
 #define USE_BURN_STACK
 
+/******************************************************************************/
+/*
+	On non POSIX compliant systems the certificate validation tests are not
+	performed and certificates have their auth flags updated with
+	cert->authFailFlags |= PS_CERT_AUTH_FAIL_DATE_FLAG;
+	which means that all certificates will fail the date validation test
+
+	If you enable ALL_CERTS_PASS_DATE_VALIDATION then all certificates
+	will pass the certificate date validation test
+
+	Again, this works only for non POSIX compliant systems
+*/
+/* #define ALL_CERTS_PASS_DATE_VALIDATION */
 
 #endif /* _h_PS_CRYPTOCONFIG */
 /******************************************************************************/
-
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/keyformat/x509.c matrixssl-3-7-2b-open/crypto/keyformat/x509.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/keyformat/x509.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/keyformat/x509.c	2016-02-11 11:42:41.000000000 -0800
@@ -2302,8 +2302,13 @@
 #else
 #warning "CERTIFICATE DATE VALIDITY NOT SUPPORTED ON THIS PLATFORM."
 #endif
-	cert->authFailFlags |= PS_CERT_AUTH_FAIL_DATE_FLAG;
+
+#ifdef ALL_CERTS_PASS_DATE_VALIDATION
 	return 0;
+#else
+	cert->authFailFlags |= PS_CERT_AUTH_FAIL_DATE_FLAG;
+#endif
+
 #endif /* POSIX */
 }
 
@@ -3026,7 +3031,12 @@
 
 		/* Ensure keyCertSign of KeyUsage. The second byte of the BIT STRING
 			will always contain the relevant information. */
-		if ( ! (ic->extensions.keyUsageFlags & KEY_USAGE_KEY_CERT_SIGN)) {
+		
+		// Added constrain to perform this check only if the issuer certificate is not the last
+		// (self-signed) certificate in the chain. By design, matrixSSL duplicates the self-signed
+		// last CA entry. The caller of this function expects the last entry in the chain to fail
+		// this test but not the penultimate one
+		if ((ic->next != NULL) && (ic != ic->next) && !(ic->extensions.keyUsageFlags & KEY_USAGE_KEY_CERT_SIGN)) {
 			/* @security If keyUsageFlags is zero, it may not exist at all
 				in the cert. This is allowed if the cert was issued before
 				the RFC was updated to require this field for CA certificates.
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_montgomery_reduce.c matrixssl-3-7-2b-open/crypto/math/pstm_montgomery_reduce.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_montgomery_reduce.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/math/pstm_montgomery_reduce.c	2016-02-11 11:42:41.000000000 -0800
@@ -61,7 +61,7 @@
    "movl %%edx,%1 \n\t"                                   \
 :"=g"(_c[LO]), "=r"(cy)                                   \
 :"0"(_c[LO]), "1"(cy), "g"(mu), "g"(*tmpm++)              \
-: "%eax", "%edx", "%cc")
+: "%eax", "%edx", "cc")
 
 #define PROPCARRY                           \
 asm(                                        \
@@ -70,7 +70,7 @@
    "movzbl %%al,%1 \n\t"                    \
 :"=g"(_c[LO]), "=r"(cy)                     \
 :"0"(_c[LO]), "1"(cy)                       \
-: "%eax", "%cc")
+: "%eax", "cc")
 
 /******************************************************************************/
 #elif defined(PSTM_X86_64)
@@ -223,7 +223,7 @@
 	" STR    r0,%1            \n\t" \
 	:"=r"(cy),"=m"(_c[0])\
 	:"0"(cy),"r"(mu),"r"(*tmpm++),"m"(_c[0])\
-	:"r0","%cc");
+	:"r0","cc");
 #define PROPCARRY                  \
 asm(                               \
 	" LDR   r0,%1            \n\t" \
@@ -234,7 +234,7 @@
 	" MOVCC %0,#0            \n\t" \
 	:"=r"(cy),"=m"(_c[0])\
 	:"0"(cy),"m"(_c[0])\
-	:"r0","%cc");
+	:"r0","cc");
 #else /* Non-Thumb2 code */
 //#pragma message ("Using 32 bit ARM Assembly Optimizations")
 #define INNERMUL                    \
@@ -247,7 +247,7 @@
 	" STR    r0,%1            \n\t" \
 	:"=r"(cy),"=m"(_c[0])\
 	:"0"(cy),"r"(mu),"r"(*tmpm++),"m"(_c[0])\
-	:"r0","%cc");
+	:"r0","cc");
 #define PROPCARRY                  \
 asm(                               \
 	" LDR   r0,%1            \n\t" \
@@ -257,7 +257,7 @@
 	" MOVCC %0,#0            \n\t" \
 	:"=r"(cy),"=m"(_c[0])\
 	:"0"(cy),"m"(_c[0])\
-	:"r0","%cc");
+	:"r0","cc");
 #endif /* __thumb2__ */
 
 
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_mul_comba.c matrixssl-3-7-2b-open/crypto/math/pstm_mul_comba.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_mul_comba.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/math/pstm_mul_comba.c	2016-02-11 11:42:41.000000000 -0800
@@ -73,7 +73,7 @@
 	 "addl  %%eax,%0     \n\t"                            \
 	 "adcl  %%edx,%1     \n\t"                            \
 	 "adcl  $0,%2        \n\t"                            \
-	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","%cc");
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","cc");
 
 /******************************************************************************/
 #elif defined(PSTM_X86_64)
@@ -142,7 +142,7 @@
 	"  ADDS   %0,%0,r0              \n\t"                     \
 	"  ADCS   %1,%1,r1              \n\t"                     \
 	"  ADC    %2,%2,#0              \n\t"                     \
-	:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+	:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "cc");
 
 /******************************************************************************/
 #elif defined(PSTM_MIPS)
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_sqr_comba.c matrixssl-3-7-2b-open/crypto/math/pstm_sqr_comba.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/math/pstm_sqr_comba.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/math/pstm_sqr_comba.c	2016-02-11 11:42:41.000000000 -0800
@@ -66,7 +66,7 @@
 	 "addl  %%eax,%0     \n\t"                            \
 	 "adcl  %%edx,%1     \n\t"                            \
 	 "adcl  $0,%2        \n\t"                            \
-	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i) :"%eax","%edx","%cc");
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i) :"%eax","%edx","cc");
 
 #define SQRADD2(i, j)                                     \
 asm(                                            \
@@ -78,7 +78,7 @@
 	 "addl  %%eax,%0     \n\t"                            \
 	 "adcl  %%edx,%1     \n\t"                            \
 	 "adcl  $0,%2        \n\t"                            \
-	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","%cc");
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","cc");
 
 #define SQRADDSC(i, j)                                    \
 asm(                                                     \
@@ -87,7 +87,7 @@
 	 "movl  %%eax,%0     \n\t"                            \
 	 "movl  %%edx,%1     \n\t"                            \
 	 "xorl  %2,%2        \n\t"                            \
-	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","%cc");
+	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","cc");
 
 #define SQRADDAC(i, j)                                    \
 asm(                                                     \
@@ -96,7 +96,7 @@
 	 "addl  %%eax,%0     \n\t"                            \
 	 "adcl  %%edx,%1     \n\t"                            \
 	 "adcl  $0,%2        \n\t"                            \
-	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","%cc");
+	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","cc");
 
 #define SQRADDDB                                          \
 asm(                                                     \
@@ -106,7 +106,7 @@
 	 "addl %6,%0         \n\t"                            \
 	 "adcl %7,%1         \n\t"                            \
 	 "adcl %8,%2         \n\t"                            \
-	 :"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(sc0), "r"(sc1), "r"(sc2) : "%cc");
+	 :"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(sc0), "r"(sc1), "r"(sc2) : "cc");
 
 /******************************************************************************/
 #elif defined(PSTM_X86_64)
@@ -209,7 +209,7 @@
 "  ADDS   %0,%0,r0                 \n\t"                         \
 "  ADCS   %1,%1,r1                 \n\t"                         \
 "  ADC    %2,%2,#0                 \n\t"                         \
-:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i) : "r0", "r1", "%cc");
+:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i) : "r0", "r1", "cc");
 
 /* for squaring some of the terms are doubled... */
 #define SQRADD2(i, j)                                            \
@@ -221,13 +221,13 @@
 "  ADDS   %0,%0,r0                 \n\t"                         \
 "  ADCS   %1,%1,r1                 \n\t"                         \
 "  ADC    %2,%2,#0                 \n\t"                         \
-:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "cc");
 
 #define SQRADDSC(i, j)                                           \
 asm(                                                             \
 "  UMULL  %0,%1,%6,%7              \n\t"                         \
 "  SUB    %2,%2,%2                 \n\t"                         \
-:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "%cc");
+:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "cc");
 
 #define SQRADDAC(i, j)                                           \
 asm(                                                             \
@@ -235,7 +235,7 @@
 "  ADDS   %0,%0,r0                 \n\t"                         \
 "  ADCS   %1,%1,r1                 \n\t"                         \
 "  ADC    %2,%2,#0                 \n\t"                         \
-:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "r0", "r1", "cc");
 
 #define SQRADDDB                                                 \
 asm(                                                             \
@@ -245,7 +245,7 @@
 "  ADDS  %0,%0,%3                     \n\t"                      \
 "  ADCS  %1,%1,%4                     \n\t"                      \
 "  ADC   %2,%2,%5                     \n\t"                      \
-:"=r"(c0), "=r"(c1), "=r"(c2) : "r"(sc0), "r"(sc1), "r"(sc2), "0"(c0), "1"(c1), "2"(c2) : "%cc");
+:"=r"(c0), "=r"(c1), "=r"(c2) : "r"(sc0), "r"(sc1), "r"(sc2), "0"(c0), "1"(c1), "2"(c2) : "cc");
 
 /******************************************************************************/
 #elif defined(PSTM_MIPS)
@@ -316,7 +316,7 @@
 	" mflo   %0             \n\t"  \
 	" mfhi   %1             \n\t"  \
 	" xor    %2,%2,%2       \n\t"  \
-	:"=r"(sc0), "=r"(sc1), "=r"(sc2):"0"(sc0), "1"(sc1), "2"(sc2), "r"(i),"r"(j) : "%cc");
+	:"=r"(sc0), "=r"(sc1), "=r"(sc2):"0"(sc0), "1"(sc1), "2"(sc2), "r"(i),"r"(j) : "cc");
 
 #define SQRADDAC(i, j)            \
 asm(                              \
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/pubkey/pkcs.c matrixssl-3-7-2b-open/crypto/pubkey/pkcs.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/crypto/pubkey/pkcs.c	2015-03-18 13:57:05.000000000 -0700
+++ matrixssl-3-7-2b-open/crypto/pubkey/pkcs.c	2016-02-11 11:42:41.000000000 -0800
@@ -913,7 +913,9 @@
 		memset_s(decryptKey, keyLen, 0x0, keyLen);
 		psFree(decryptKey, pool);
 	}
-	psFree(decryptKey, pool);
+
+	// if decryptKey != NULL then it's freed above
+	// psFree(decryptKey, pool);
 	psFree(iv, pool);
 
 	*plaintext = pt;
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/cipherSuite.c matrixssl-3-7-2b-open/matrixssl/cipherSuite.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/cipherSuite.c	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/cipherSuite.c	2016-02-11 11:42:41.000000000 -0800
@@ -1777,33 +1777,33 @@
 	int32	i = 0;
 
 	if (cipherSpecLen == 0) {
-		if (sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA) ||
+		if (sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, NULL) ||
 #ifdef USE_TLS_1_2
-				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)||
-				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)||
-				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256) ||
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, NULL)||
+				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, NULL)||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, NULL)||
+				sslGetCipherSpec(ssl, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, NULL)||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, NULL) ||
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384, NULL) ||
 #endif
-				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA)) {
+				sslGetCipherSpec(ssl, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, NULL)) {
 			return 1;
 		}
 	} else {
@@ -1874,8 +1874,11 @@
 	Lookup the given cipher spec ID and return a pointer to the structure
 	if found.  This is used when negotiating security, to find out what suites
 	we support.
+
+	If a cipher is found and the index pointer is not NULL then the cipher's
+	index according to our list is returned in the index pointer
 */
-sslCipherSpec_t *sslGetCipherSpec(ssl_t *ssl, uint32 id)
+sslCipherSpec_t *sslGetCipherSpec(ssl_t *ssl, uint32 id, int16 *index)
 {
 	int16	i;
 #ifdef USE_SERVER_SIDE_SSL
@@ -1953,11 +1956,13 @@
 			/*	Unusable due to key material not available? */
 #ifdef VALIDATE_KEY_MATERIAL
 			if (haveKeyMaterial(ssl, supportedCiphers[i].type, 0) == PS_SUCCESS) {
+				if (index != NULL) *index = i;
 				return &supportedCiphers[i];
 			}
 			psTraceIntInfo("Matched cipher suite %d but no supporting keys\n",
 				id);
 #else
+			if (index != NULL) *index = i;
 			return &supportedCiphers[i];
 #endif /* VALIDATE_KEY_MATERIAL */
 		}
@@ -2014,6 +2019,7 @@
 	}
 	i *= 2;
 	i -= (unsigned short)ignored;
+
 #ifdef ENABLE_SECURE_REHANDSHAKES
 	if (addScsv == 1) {
 #ifdef USE_CLIENT_SIDE_SSL
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslApi.c matrixssl-3-7-2b-open/matrixssl/matrixsslApi.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslApi.c	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/matrixsslApi.c	2016-02-11 11:42:41.000000000 -0800
@@ -215,6 +215,98 @@
 #endif /* USE_CLIENT_SIDE_SSL */
 
 #ifdef USE_SERVER_SIDE_SSL
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+
+/******************************************************************************/
+/*
+	Loads the OCSP DER response for the session from the specified file
+	This exact content will be sent when a client sends a "status request"
+	extension in its CLIENT_HELLO message
+
+	Subsequent calls to this functions refresh the OCSP DER response inside
+	the ssl structure
+
+	Calling this function with a NULL DERfile parameter will free the memory
+	if allocated in the past
+
+	Note that this is inefficient as the OCSP DER response will be loaded
+	for each session. A more efficient approach is to manage the OCSP DER
+	response buffer yourself and just call matrixSslSetOcspDER to setup the
+	pointer and size
+*/
+int32 matrixSslLoadOcspDER(ssl_t *ssl, const unsigned char *DERfile)
+{
+	int32 rc = PS_SUCCESS;
+	
+	// free previous loaded OCSP DER if any
+	if (ssl->status_request_DER_must_free) {
+		psFree(ssl->status_request_DER, NULL);
+		ssl->status_request_DER = NULL;
+		ssl->status_request_DER_size = 0;
+		ssl->status_request_DER_must_free = 0;
+	}
+
+	// read the new file (if specified)
+	if (DERfile != NULL) {
+		rc = psGetFileBuf(NULL, DERfile, &ssl->status_request_DER, &ssl->status_request_DER_size);
+	
+		if (rc == PS_SUCCESS) {
+			// signal that we must free when the session is done
+			ssl->status_request_DER_must_free = 1;
+		}
+	}
+
+	psTraceIntInfo("Loaded OCSP DER size = %d\n", ssl->status_request_DER_size);
+	psTracePtrCore("SSL = %p\n", ssl);
+	psTracePtrCore("DER = %p\n", ssl->status_request_DER);
+	psTraceIntInfo("DERs = %d\n", ssl->status_request_DER_size);
+	
+	return rc;
+}
+
+/******************************************************************************/
+/*
+	Sets up the pointer and size of an OCSP DER response freeing a previoulsy
+	loaded OCSP DER response if necessary
+*/
+int32 matrixSslSetOcspDER(ssl_t *ssl, unsigned char *OCSP_DER, int32 OCSP_DER_size)
+{
+	// check if an OCSP DER response is already loaded so we free the allocated
+	// memory before setting the pointer to prevent leaks
+	if (ssl->status_request_DER_must_free) {
+		psFree(ssl->status_request_DER, NULL);
+		ssl->status_request_DER = NULL;
+		ssl->status_request_DER_size = 0;
+		ssl->status_request_DER_must_free = 0;
+	}
+	
+	// setup the new pointer and size
+	ssl->status_request_DER = OCSP_DER;
+	ssl->status_request_DER_size = OCSP_DER_size;
+	
+	return PS_SUCCESS;
+}
+
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+
+/******************************************************************************/
+/*
+	Sets up the session's SCT buffer and SCT buffer size using a buffer
+	containing one or more SCT entries
+*/
+int32 matrixSslSetSCT(ssl_t *ssl, unsigned char *SCT, int32 SCT_size)
+{
+	ssl->SCT = SCT;
+	ssl->SCT_size = SCT_size;
+	
+	return PS_SUCCESS;
+}
+
+#endif /* ENABLE_SIGNED_CERTIFICATE_TIMESTAMP */
+
 /******************************************************************************/
 /*
 	Create a new server SSL session
@@ -288,9 +380,11 @@
 }
 
 void matrixSslRegisterSNICallback(ssl_t *ssl, void (*sni_cb)(void *ssl,
-	char *hostname, int32 hostnameLen, sslKeys_t **newKeys))
+	char *hostname, int32 hostnameLen, sslKeys_t **newKeys, void *userPtr), void *sni_cb_userPtr, int32 ssl_id)
 {
 	ssl->sni_cb = sni_cb;
+	ssl->sni_cb_userPtr = sni_cb_userPtr;
+	ssl->ssl_id = ssl_id;
 }
 
 #ifdef USE_ALPN
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslApi.h matrixssl-3-7-2b-open/matrixssl/matrixsslApi.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslApi.h	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/matrixsslApi.h	2016-02-11 11:42:41.000000000 -0800
@@ -182,6 +182,13 @@
 /*
 	Server side APIs
 */
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+PSPUBLIC int32 matrixSslLoadOcspDER(ssl_t *ssl, const unsigned char* DERfile);
+PSPUBLIC int32 matrixSslSetOcspDER(ssl_t *ssl, unsigned char *OCSP_DER, int32 OCSP_DER_size);
+#endif
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+PSPUBLIC int32 matrixSslSetSCT(ssl_t *ssl, unsigned char *SCT, int32 SCT_size);
+#endif
 PSPUBLIC int32 matrixSslNewServerSession(ssl_t **ssl, const sslKeys_t *keys,
 				int32 (*certCb)(ssl_t *ssl, psX509Cert_t *cert, int32 alert),
 				sslSessOpts_t *options);
@@ -189,7 +196,7 @@
 				uint32 status);
 PSPUBLIC void matrixSslRegisterSNICallback(ssl_t *ssl,
 				void (*sni_cb)(void *ssl, char *hostname, int32 hostnameLen,
-					sslKeys_t **newKeys));
+					sslKeys_t **newKeys, void *userPtr), void *sni_cb_userPtr, int32 ssl_id);
 
 #ifdef USE_ALPN
 PSPUBLIC void matrixSslRegisterALPNCallback(ssl_t *ssl,
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixssl.c matrixssl-3-7-2b-open/matrixssl/matrixssl.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixssl.c	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/matrixssl.c	2016-02-11 11:42:41.000000000 -0800
@@ -56,7 +56,12 @@
 #endif
 #endif /* USE_MULTITHREADING */
 
+#ifdef USE_SHARED_SESSION_CACHE
+sslSessionEntry_t		*sessionTable;
+#else
 static sslSessionEntry_t	sessionTable[SSL_SESSION_TABLE_SIZE];
+#endif
+
 static DLListEntry          sessionChronList;
 static void initSessionEntryChronList();
 #endif /* USE_SERVER_SIDE_SSL */
@@ -113,8 +118,19 @@
 	}
 #endif
 
-
 #ifdef USE_SERVER_SIDE_SSL
+
+#ifdef USE_SHARED_SESSION_CACHE
+	sessionTable = (sslSessionEntry_t *) mmap(NULL, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+
+	if (sessionTable == MAP_FAILED) {
+		psError("error creating shared memory\n");
+		return PS_FAILURE;
+	}
+
+	psTracePtrCore("sessionTable = %p\n", sessionTable);
+#endif
+
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
 
@@ -150,6 +166,11 @@
 	}
 	memset(sessionTable, 0x0,
 		sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+
+#ifdef USE_SHARED_SESSION_CACHE
+	munmap(sessionTable, sizeof(sslSessionEntry_t) * SSL_SESSION_TABLE_SIZE);
+#endif
+
 #ifdef USE_MULTITHREADING
 	psUnlockMutex(&sessionTableLock);
 	psDestroyMutex(&sessionTableLock);
@@ -1117,7 +1138,7 @@
 
 	lssl->sPool = pool;
 	lssl->keys = (sslKeys_t*)keys;
-	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL);
+	lssl->cipher = sslGetCipherSpec(lssl, SSL_NULL_WITH_NULL_NULL, NULL);
 	sslActivateReadCipher(lssl);
 	sslActivateWriteCipher(lssl);
 
@@ -1298,7 +1319,7 @@
 
 		lssl->hsState = SSL_HS_SERVER_HELLO;
 		if (session != NULL && session->cipherId != SSL_NULL_WITH_NULL_NULL) {
-			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId);
+			lssl->cipher = sslGetCipherSpec(lssl, session->cipherId, NULL);
 			if (lssl->cipher == NULL) {
 				psTraceInfo("Invalid session id to matrixSslNewSession\n");
 			} else {
@@ -1551,6 +1572,12 @@
 		psFree(ssl->alpn, ssl->sPool); ssl->alpn = NULL;
 	}
 #endif
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+	if ((ssl->status_request_DER_size > 0) && (ssl->status_request_DER_must_free))
+		psFree(ssl->status_request_DER, NULL);
+#endif
+
 /*
 	The cipher and mac contexts are inline in the ssl structure, so
 	clearing the structure clears those states as well.
@@ -2107,7 +2134,7 @@
 	if (ssl->sni_cb) {
 		ssl->extFlags.sni = 1; /* extension was actually handled */
 		keys = NULL;
-		(ssl->sni_cb)((void*)ssl, host, hostLen, &keys) ;
+		(ssl->sni_cb)((void *) ssl, host, hostLen, &keys, ssl->sni_cb_userPtr, ssl->ssl_id);
 		if (keys) {
 			ssl->keys = keys;
 			return 0;
@@ -2495,7 +2522,7 @@
 	cipherSuite += *enc; enc++;
 
 	/* Force cipher suite */
-	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite)) == NULL) {
+	if ((ssl->cipher = sslGetCipherSpec(ssl, cipherSuite, NULL)) == NULL) {
 		psTraceInfo("Cipher suite check failure on session ticket\n");
 		return PS_FAILURE;
 	}
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslConfig.h matrixssl-3-7-2b-open/matrixssl/matrixsslConfig.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixsslConfig.h	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/matrixsslConfig.h	2016-02-11 11:42:41.000000000 -0800
@@ -61,9 +61,9 @@
 	the handshake will determine which is best for the connection.
 */
 
-#define USE_TLS_RSA_WITH_AES_128_CBC_SHA
+/* #define USE_TLS_RSA_WITH_AES_128_CBC_SHA */
 #define USE_TLS_RSA_WITH_AES_256_CBC_SHA
-#define USE_TLS_RSA_WITH_AES_128_CBC_SHA256 /* TLS 1.2 */
+/* #define USE_TLS_RSA_WITH_AES_128_CBC_SHA256 */ /* TLS 1.2 */ 
 #define USE_TLS_RSA_WITH_AES_256_CBC_SHA256 /* TLS 1.2 */
 /* #define USE_TLS_RSA_WITH_AES_128_GCM_SHA256 */ /* TLS 1.2 */
 /* #define USE_TLS_RSA_WITH_AES_256_GCM_SHA384 */ /* TLS 1.2 */
@@ -380,6 +380,30 @@
 */
 /* #define USE_ZLIB_COMPRESSION */	/* @security INSECURE */
 
+/******************************************************************************/
+/*
+	Protection against protocol downgrade attacks.
+	https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+*/
+
+#define ENABLE_TLS_FALLBACK_SCSV
+
+/******************************************************************************/
+/*
+	Partial implementation of the Certificate Status Request extension
+	https://tools.ietf.org/html/rfc6066#section-8
+*/
+
+/* #define ENABLE_CERTIFICATE_STATUS_REQUEST */
+
+/******************************************************************************/
+/*
+	Implementation of the Certificate Transparency extension
+	(signed_certificate_timestamp)
+	https://tools.ietf.org/html/rfc6962
+*/
+
+/* #define ENABLE_SIGNED_CERTIFICATE_TIMESTAMP */
 
 #ifdef __cplusplus
 }
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixssllib.h matrixssl-3-7-2b-open/matrixssl/matrixssllib.h
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/matrixssllib.h	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/matrixssllib.h	2016-02-11 11:42:41.000000000 -0800
@@ -1164,6 +1164,7 @@
 #define SSL_ALERT_PROTOCOL_VERSION			70
 #define SSL_ALERT_INSUFFICIENT_SECURITY		71
 #define SSL_ALERT_INTERNAL_ERROR			80
+#define SSL_ALERT_INAPPROPRIATE_FALLBACK		86
 #define SSL_ALERT_NO_RENEGOTIATION			100
 #define SSL_ALERT_UNSUPPORTED_EXTENSION		110
 #define SSL_ALERT_UNRECOGNIZED_NAME			112
@@ -1274,6 +1275,7 @@
 #define SSL_HS_CERTIFICATE_VERIFY	15
 #define SSL_HS_CLIENT_KEY_EXCHANGE	16
 #define SSL_HS_FINISHED				20
+#define SSL_HS_CERTIFICATE_STATUS		22
 #define SSL_HS_DONE					255	/* Handshake complete (internal) */
 
 #define	INIT_ENCRYPT_CIPHER		0
@@ -1282,6 +1284,7 @@
 #define HMAC_CREATE	1
 #define HMAC_VERIFY 2
 
+#define CERTIFICATE_STATUS_OCSP		1
 
 #ifdef USE_TLS_1_2
 #define HASH_SIG_256_RSA	0x0401	/* SHA256 hash and RSA sig */
@@ -1334,6 +1337,7 @@
 #define TLS_RSA_WITH_AES_128_CBC_SHA		0x002F		/* 47 */
 #define TLS_RSA_WITH_AES_256_CBC_SHA		0x0035		/* 53 */
 #define TLS_EMPTY_RENEGOTIATION_INFO_SCSV	0x00FF
+#define TLS_FALLBACK_SCSV                       0x5600
 
 #define TLS_RSA_WITH_IDEA_CBC_SHA			0x0007		/* 7 */
 #define	SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA	0x0016		/* 22 */
@@ -1390,10 +1394,12 @@
 #define EXT_SNI							 0
 #define EXT_MAX_FRAGMENT_LEN			 1
 #define EXT_TRUNCATED_HMAC				 4
+#define EXT_STATUS_REQUEST				5
 #define EXT_ELLIPTIC_CURVE				10	/* Client-send only */
 #define EXT_ELLIPTIC_POINTS				11
 #define EXT_SIGNATURE_ALGORITHMS		13
 #define EXT_ALPN						16
+#define EXT_SIGNED_CERTIFICATE_TIMESTAMP		18
 #define EXT_SESSION_TICKET				35
 #define EXT_RENEGOTIATION_INFO			0xFF01
 
@@ -1744,7 +1750,10 @@
 #ifdef USE_SERVER_SIDE_SSL
 	uint16			disabledCiphers[SSL_MAX_DISABLED_CIPHERS];
 	void			(*sni_cb)(void *ssl, char *hostname, int32 hostnameLen,
-						sslKeys_t **newKeys);
+						sslKeys_t **newKeys, void *userPtr, int32 ssl_id);
+	void			*sni_cb_userPtr;
+	int32			ssl_id;
+
 #ifdef USE_ALPN
 	void			(*srv_alpn_cb)(void *ssl, short protoCount,
 						char *proto[MAX_PROTO_EXT],
@@ -1874,6 +1883,20 @@
 	void *memAllocPtr; /* Will be passed to psOpenPool for each call
 							related to this session */
 	void *userPtr;
+	
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+	/* DER buffer for status request extension */
+	char status_request;
+	unsigned char *status_request_DER;
+	int32 status_request_DER_size;
+	char status_request_DER_must_free;
+#endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+	char SCT_request;
+	unsigned char* SCT;
+	int32 SCT_size;
+#endif
 } ssl_t;
 
 /* Type to pass optional features to NewSession calls */
@@ -1994,7 +2017,7 @@
 /*
 	cipherSuite.c
 */
-extern sslCipherSpec_t *sslGetCipherSpec(ssl_t *ssl, uint32 cid);
+extern sslCipherSpec_t *sslGetCipherSpec(ssl_t *ssl, uint32 cid, int16 *index);
 extern int32 sslGetCipherSpecListLen(ssl_t *ssl);
 extern int32 sslGetCipherSpecList(ssl_t *ssl, unsigned char *c, int32 len,
 				int32 addScsv);
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/sslDecode.c matrixssl-3-7-2b-open/matrixssl/sslDecode.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/sslDecode.c	2015-03-18 13:57:06.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/sslDecode.c	2016-02-11 11:55:25.000000000 -0800
@@ -1322,9 +1322,16 @@
 {
 	unsigned char	*c, *end;
 	unsigned char	hsType;
+	// variables used when walking through client provided cipher list
+	// all indexes are relative to our supportedCiphers list (see cipherSuite.c)
+	//   cipherIndex is the current tested cipher
+	//   bestCipherIndex is the strongest cipher according to our list
+	//   firstCipherIndex is the first cipher in the client's list
+	int16	 cipherIndex, bestCipherIndex, firstCipherIndex;
 	int32			rc, i = 0;
+	sslCipherSpec_t	*foundCipher;
 	short			renegotiationExt;
-	uint32			hsLen, extLen, extType, cipher = 0;
+	uint32			hsLen, extLen, extType, cipher = 0, bestCipher = 0;
 	unsigned char	hsMsgHash[SHA384_HASH_SIZE];
 	void			*pkiData = ssl->userPtr;
 
@@ -1741,7 +1748,18 @@
 		Client should always be sending highest supported protocol.  Server
 		will reply with a match or a lower version if enabled (or forced).
 */
+
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+/*		Remember if we forced a downgrade so we know which versions to compare
+		and we don't reject the handshake if TLS_FALLBACK_SCSV is specified.
+*/
+		int16 forcedMin = 0;
+#endif
+
 		if (ssl->majVer != 0) {
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+			forcedMin = 1;
+#endif
 			/* If our forced server version is a later protocol than their
 				request, we have to exit */
 			if (ssl->reqMinVer < ssl->minVer) {
@@ -1775,7 +1793,7 @@
 #endif
 				}
 #ifdef USE_TLS_1_2
-				if (compareMin == TLS_1_2_MIN_VER) {
+				if (compareMin >= TLS_1_2_MIN_VER) {
 					ssl->minVer = TLS_1_2_MIN_VER;
 					ssl->flags |= SSL_FLAGS_TLS_1_2 | SSL_FLAGS_TLS_1_1 | SSL_FLAGS_TLS;
 				}
@@ -1910,10 +1928,13 @@
 				psTraceInfo("Malformed clientHello message\n");
 				return MATRIXSSL_ERROR;
 			}
-#ifdef ENABLE_SECURE_REHANDSHAKES
+#ifdef ENABLE_SECURE_REHANDSHAKES || ENABLE_TLS_FALLBACK_SCSV
 /*
 			Below we stop looking after the first cipher we match but we need
 			to search for SCSV if secure rehandshakes are on and first conn
+
+			Also we need to check if the client provided TLS_FALLBACK_SCSV and
+			act accordingly if he did
 */
 			if (ssl->myVerifyDataLen == 0) {
 				extLen = 0; /* just overloading existing var */
@@ -1923,10 +1944,44 @@
 					if (cipher == TLS_EMPTY_RENEGOTIATION_INFO_SCSV) {
 						ssl->secureRenegotiationFlag = PS_TRUE;
 					}
+#ifdef ENABLE_TLS_FALLBACK_SCSV
+					if (cipher == TLS_FALLBACK_SCSV) {
+/*						If the client supports TLS 1.1 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should NOT send the alert (the
+						protocol downgrade was set by us)
+
+						If the client supports TLS 1.0 and we support 1.2 but for some
+						reason we forced 1.1 usage, we should send the alert
+*/
+						if ((forcedMin && (ssl->reqMinVer < ssl->minVer)) ||
+
+/*						If TLS version was not enforced by us, we compare to our highest
+						supported version
+*/
+#ifdef USE_TLS_1_2
+						(!forcedMin && (ssl->reqMinVer < TLS_1_2_MIN_VER))
+#else
+#ifdef USE_TLS_1_1
+						(!forcedMin && (ssl->reqMinVer < TLS_1_1_MIN_VER))
+#else
+						(!forcedMin && (ssl->reqMinVer < TLS_MIN_VER))
+#endif
+#endif
+						) {
+							ssl->err = SSL_ALERT_INAPPROPRIATE_FALLBACK;
+							psTraceInfo("FALLBACK_SCSV is specified and we can do better. Reject handshake");
+							return MATRIXSSL_ERROR;
+						}
+					}
+#endif /* ENABLED_TLS_FALLBACK_SCSV */
 				}
 			}
 #endif
 			p = c + suiteLen;
+
+			// Setup to find the stronget cipher the client supports
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 8; c++;
 				cipher += *c; c++;
@@ -1941,12 +1996,25 @@
 						break;
 					}
 				} else {
-					if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-						c = p;
-						break;
+					if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+						// Save the first cipher found - debuggin only
+						if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+
+						// Check if the current supported cipher index is lower than the best cipher index
+						// this means that we found a stroner cipher and we must save it
+						if (cipherIndex < bestCipherIndex) {
+							bestCipherIndex = cipherIndex;
+							ssl->cipher = foundCipher;
+							bestCipher = cipher;
+						}
 					}
 				}
 			}
+			
+			//if (firstCipherIndex != bestCipherIndex) psTraceInfo("Overriding client cipher preferences");
+
+			// Use the best cipher we found
+			if (cipherIndex > -1) cipher = bestCipher;
 /*
 			If we fell to the default cipher suite, we didn't have
 			any in common with the client, or the client is being bad
@@ -1955,7 +2023,7 @@
 			if (ssl->cipher == NULL || ssl->cipher->ident != cipher ||
 					cipher == SSL_NULL_WITH_NULL_NULL) {
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				return MATRIXSSL_ERROR;
 			}
@@ -2496,6 +2564,43 @@
 						}
 					}
 #endif
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+					if (extType == EXT_STATUS_REQUEST) {
+						/* Must hold 1 b status type, 2 b list len, 2 b list len */
+						if (extLen < 1 + 2 + 2) {
+							psTraceInfo("Invalid status request ext len\n");
+							ssl->err = SSL_ALERT_ILLEGAL_PARAMETER;
+							return MATRIXSSL_ERROR;
+						}
+
+						if (*c == CERTIFICATE_STATUS_OCSP) {
+/*							For now OCSP staples are supported only if the client
+							doesn't send us responder IDs or OCSP extensions
+*/
+							if ((((int16) *(c + 1)) == 0) && (((int16) *(c + 3)) == 0)) {
+								/* Only respond if we have something to send */
+								if (ssl->status_request_DER_size > 0)
+									ssl->status_request = 1;
+							}
+						}
+					}
+#endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+					if (extType == EXT_SIGNED_CERTIFICATE_TIMESTAMP) {
+						/* Only respond if we have something to send */
+						if (ssl->SCT_size > 0)
+							ssl->SCT_request = 1;
+					}
+#endif
+
+/*
+psTraceIntInfo("extType = %d ", extType);
+psTraceIntInfo("extLen = %d\n", extLen);
+psTraceBytes(NULL, c, extLen);
+*/
+
 					c += extLen;
 				}
 			}
@@ -2652,18 +2757,30 @@
 			need to worry about matching resumed cipher suite.
 */
 			p = c + suiteLen;
+
+			// Prepare variables to detect best client supported cipher
+			cipherIndex = -1; bestCipherIndex = 32767; firstCipherIndex = -1;
+
 			while (c < p) {
 				cipher = *c << 16; c++;
 				cipher += *c << 8; c++;
 				cipher += *c; c++;
-				if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) != NULL) {
-					c = p;
-					break;
+				
+				if ((foundCipher = sslGetCipherSpec(ssl, cipher, &cipherIndex)) != NULL) {
+					if (firstCipherIndex == -1) firstCipherIndex = cipherIndex;
+					if (cipherIndex < bestCipherIndex) {
+						bestCipherIndex = cipherIndex;
+						ssl->cipher = foundCipher;
+						bestCipher = cipher;
+					}
 				}
 			}
+
+			if (cipherIndex > -1) cipher = bestCipher;
+
 			if (ssl->cipher == NULL ||
 					ssl->cipher->ident == SSL_NULL_WITH_NULL_NULL) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceInfo("No matching cipher for SSL handshake\n");
 				return MATRIXSSL_ERROR;
@@ -3471,7 +3588,7 @@
 				if (memcmp(ssl->sessionId, c, sessionIdLen) == 0) {
 					ssl->flags |= SSL_FLAGS_RESUMED;
 				} else {
-					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL);
+					ssl->cipher = sslGetCipherSpec(ssl,SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 					memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3489,7 +3606,7 @@
 			c += sessionIdLen;
 		} else {
 			if (ssl->sessionIdLen > 0) {
-				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL);
+				ssl->cipher = sslGetCipherSpec(ssl, SSL_NULL_WITH_NULL_NULL, NULL);
 #ifndef USE_PKCS11_TLS_ALGS
 				memset(ssl->sec.masterSecret, 0x0, SSL_HS_MASTER_SIZE);
 #endif
@@ -3524,7 +3641,7 @@
 				return MATRIXSSL_ERROR;
 			}
 		} else {
-			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher)) == NULL) {
+			if ((ssl->cipher = sslGetCipherSpec(ssl, cipher, NULL)) == NULL) {
 				ssl->err = SSL_ALERT_HANDSHAKE_FAILURE;
 				psTraceIntInfo("Can't support requested cipher: %d\n", cipher);
 				return MATRIXSSL_ERROR;
diff -ur ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/sslEncode.c matrixssl-3-7-2b-open/matrixssl/sslEncode.c
--- ../Crypt-MatrixSSL3-3.7.2/matrixssl-3-7-2b-open/matrixssl/sslEncode.c	2015-07-06 17:03:28.000000000 -0700
+++ matrixssl-3-7-2b-open/matrixssl/sslEncode.c	2016-02-11 11:42:41.000000000 -0800
@@ -39,6 +39,10 @@
 #ifndef USE_ONLY_PSK_CIPHER_SUITE
 static int32 writeCertificate(ssl_t *ssl, sslBuf_t *out, int32 notEmpty);
 #endif
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+#endif
 static int32 writeChangeCipherSpec(ssl_t *ssl, sslBuf_t *out);
 static int32 writeFinished(ssl_t *ssl, sslBuf_t *out);
 static int32 writeAlert(ssl_t *ssl, unsigned char level,
@@ -1185,7 +1189,25 @@
 		}
 #endif /* USE_DHE_CIPHER_SUITE */
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+/*
+		If the client send a "status request" extension we will respond with
+		a CERTIFICATE_STATUS message
+
+		Add our requirements to the final message size
+*/
+		if (ssl->status_request) {
+		    // 1 byte for the status type, 3 bytes for the OCSP DER staple
+		    messageSize += ssl->recordHeadLen + ssl->hshakeHeadLen + 1 + 3;
+
+		    // Test if DER size is too large and we need fragmentation
+		    if (ssl->status_request_DER_size > ssl->maxPtFrag)
+			messageSize += addCertFragOverhead(ssl, ssl->status_request_DER_size);
 
+		    messageSize += ssl->status_request_DER_size;
+		    messageSize += secureWriteAdditions(ssl, 1);
+		}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 /*
 		Add extensions
 */
@@ -1219,6 +1241,19 @@
 		}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+		if (ssl->status_request) {
+			extSize = 2;
+			messageSize += 4;
+		}
+#endif
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+		if (ssl->SCT_request) {
+			extSize = 2;
+			messageSize += 2 + 2 + 2 + ssl->SCT_size; /* 2 type, 2 length, data */
+		}
+#endif
 
 #ifdef ENABLE_SECURE_REHANDSHAKES
 /*
@@ -1249,12 +1284,14 @@
 /*
 		Done with extensions.  If had some, add the two byte total length
 */
+
 		messageSize += extSize;
 
 		if ((out->buf + out->size) - out->end < messageSize) {
 			*requiredLen = messageSize;
 			return SSL_FULL;
 		}
+
 /*
 		Message size complete.  Begin the flight write
 */
@@ -1268,6 +1305,12 @@
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writeCertificate(ssl, out, 1);
 				}
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 			}
 
 #endif /* !USE_ONLY_PSK_CIPHER_SUITE */
@@ -1289,6 +1332,12 @@
 #endif /* USE_DHE_CIPHER_SUITE */
 #ifdef USE_PSK_CIPHER_SUITE
 			if (ssl->flags & SSL_FLAGS_PSK_CIPHER) {
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writePskServerKeyExchange(ssl, out);
 				}
@@ -1298,6 +1347,12 @@
 				if (rc == MATRIXSSL_SUCCESS) {
 					rc = writeCertificate(ssl, out, 1);
 				}
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+				// Write OSCP DER staple if needed
+				if (ssl->status_request && (rc == MATRIXSSL_SUCCESS)) {
+					rc = writeCertificateStatus(ssl, out);
+				}
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
 #endif /* !USE_ONLY_PSK_CIPHER_SUITE */
 #ifdef USE_PSK_CIPHER_SUITE
 			}
@@ -1320,7 +1375,7 @@
 			rc = writeServerHelloDone(ssl, out);
 		}
 		if (rc == SSL_FULL) {
-			psTraceInfo("Bad flight messageSize calculation");
+			psTraceInfo("Bad flight messageSize calculation\n");
 			ssl->err = SSL_ALERT_INTERNAL_ERROR;
 			out->end = out->start;
 			alertReqLen = out->size;
@@ -2796,6 +2851,29 @@
 	}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+/*
+	If the client sent a "status request" extension we must respond by adding
+	an empty "status request" extension ourselfs and by sending a
+	CERTIFICATE_STATUS message
+*/
+	if (ssl->status_request) {
+		if (extLen == 0) {
+			extLen = 2;
+		}
+		extLen += 4; /* 2 type, 2 len = 0 */
+	}
+#endif ENABLE_CERTIFICATE_STATUS_REQUEST
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+	if (ssl->SCT_request) {
+		if (extLen == 0) {
+			extLen = 2;
+		}
+		extLen += 2 + 2 + 2 + ssl->SCT_size; /* 2 type, 2 len, data */
+	}
+#endif
+
 	messageSize += extLen;
 
 /*
@@ -2936,6 +3014,31 @@
 		}
 #endif
 
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+		// add our empty "status request" extension if the client sent us one
+		if (ssl->status_request) {
+			*c = (EXT_STATUS_REQUEST & 0xFF00) >> 8; c++;
+			*c = EXT_STATUS_REQUEST & 0xFF; c++;
+			*c = 0; c++;
+			*c = 0; c++;
+		}
+#endif ENABLE_CERTIFICATE_STATUS_REQUEST
+
+#ifdef ENABLE_SIGNED_CERTIFICATE_TIMESTAMP
+psTraceIntInfo("Send SCT size %d\n", ssl->SCT_size);
+
+		if (ssl->SCT_request) {
+			*c = (EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF00) >> 8; c++;
+			*c = EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF; c++;
+			*c = ((ssl->SCT_size + 2) & 0xFF00) >> 8; c++;
+			*c = (ssl->SCT_size + 2) & 0xFF; c++;
+			*c = (ssl->SCT_size & 0xFF00) >> 8; c++;
+			*c = ssl->SCT_size & 0xFF; c++;
+			memcpy(c, ssl->SCT, ssl->SCT_size);
+			c += ssl->SCT_size;
+		}
+#endif
+
 #ifdef ENABLE_SECURE_REHANDSHAKES
 		if (ssl->secureRenegotiationFlag == PS_TRUE) {
 			/* RenegotiationInfo*/
@@ -3757,6 +3860,7 @@
 }
 #endif /* USE_SERVER_SIDE_SSL || USE_CLIENT_AUTH */
 
+
 /******************************************************************************/
 /*
 	Write a Certificate message.
@@ -3881,6 +3985,218 @@
 	}
 	return MATRIXSSL_SUCCESS;
 }
+
+#ifdef ENABLE_CERTIFICATE_STATUS_REQUEST
+
+/*
+	A fragmented write of the CERTIFICATE_STATUS handhshake message.  This is one
+	of the handshake messages that supports fragmentation because it is one of the
+	messages where the 512byte plaintext max of the max_fragment extension can
+	be exceeded.
+*/
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+	unsigned char *DER;
+	unsigned char	*c, *end, *encryptStart;
+	char			padLen;
+	int32			messageSize, rc, DERLen;
+	int32			midWrite, midSizeWrite, countDown, firstOne = 1;
+	int32 lsize;
+
+	c = out->end;
+	end = out->buf + out->size;
+
+	midSizeWrite = midWrite = 0;
+	DER = ssl->status_request_DER;
+	DERLen = ssl->status_request_DER_size;
+	
+	lsize = 1 + 3; // 1 byte OCSP status type + 3 bytes DER length;
+
+	while (DERLen > 0) {
+		if (firstOne) {
+			firstOne = 0;
+			countDown = ssl->maxPtFrag;
+
+			messageSize = DERLen + lsize + ssl->recordHeadLen + ssl->hshakeHeadLen;
+			if ((rc = writeRecordHeader(ssl,
+					SSL_RECORD_TYPE_HANDSHAKE_FIRST_FRAG, SSL_HS_CERTIFICATE_STATUS,
+					&messageSize, &padLen, &encryptStart, &end, &c)) < 0) {
+				return rc;
+			}
+			
+			// Write the status type
+			*c = CERTIFICATE_STATUS_OCSP; c++;
+			
+			// Account for what has been written so far
+			countDown -= ssl->hshakeHeadLen + 1;
+
+			midWrite = 0;
+			if (countDown < 3) {
+				/* Fragment falls right on DER len write.  Has
+					to be at least one byte or countDown would have
+					been 0 and got us out of here already*/
+				*c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+				c++; countDown--;
+				midSizeWrite = 2;
+				if (countDown != 0) {
+					*c = (DERLen & 0xFF00) >> 8; c++; countDown--;
+					midSizeWrite = 1;
+					if (countDown != 0) {
+						*c = (DERLen & 0xFF); c++; countDown--;
+						midSizeWrite = 0;
+					}
+				}
+				goto postpone_and_next;
+			} else {
+				*c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+				c++;
+				*c = (DERLen & 0xFF00) >> 8; c++;
+				*c = (DERLen & 0xFF); c++;
+				countDown -= 3;
+			}
+			midWrite = min(DERLen, countDown);
+			memcpy(c, DER, midWrite);
+			DERLen -= midWrite;
+			c += midWrite;
+			countDown -= midWrite;
+			
+			postpone_and_next:
+			if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+					SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+					&c)) < 0) {
+				return rc;
+			}
+
+			out->end = c;
+		} else {
+/*
+			Not-first fragments
+*/
+			if (midSizeWrite > 0) {
+				messageSize = midSizeWrite;
+			} else {
+				messageSize = 0;
+			}
+			if ((DERLen + messageSize) > ssl->maxPtFrag) {
+				messageSize += ssl->maxPtFrag;
+			} else {
+				messageSize += DERLen;
+			}
+
+			countDown = messageSize;
+			messageSize += ssl->recordHeadLen;
+			/* Second, etc... */
+			if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE_FRAG,
+					SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+					&end, &c)) < 0) {
+				return rc;
+			}
+
+			if (midSizeWrite > 0) {
+				if (midSizeWrite == 2) {
+					*c = (DERLen & 0xFF00) >> 8; c++;
+					*c = (DERLen & 0xFF); c++;
+					countDown -= 2;
+				} else {
+					*c = (DERLen & 0xFF); c++;
+					countDown -= 1;
+				}
+				midSizeWrite = 0;
+			}
+
+			if (countDown < DERLen) {
+				memcpy(c, DER + midWrite, countDown);
+				DERLen -= countDown;
+				c += countDown;
+				midWrite += countDown;
+				countDown = 0;
+			} else {
+				memcpy(c, DER + midWrite, DERLen);
+				c += DERLen;
+				countDown -= DERLen;
+				DERLen -= DERLen;
+			}
+
+			if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+					SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+					&c)) < 0) {
+				return rc;
+			}
+			out->end = c;
+		}
+	}
+
+	out->end = c;
+	return MATRIXSSL_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	Write a Certificate Status message.
+	The encoding of the message is as follows:
+		1 byte status type
+		3 byte length of DER data (network byte order)
+		x bytes DER data
+*/
+
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+	unsigned char *DER;
+	uint32			DERLen;
+
+	unsigned char	*c, *end, *encryptStart;
+	char			padLen;
+	int32			lsize, messageSize, i, rc;
+
+	psTraceHs("<<< server creating CERTIFICATE_STATUS  message\n");
+
+	c = out->end;
+	end = out->buf + out->size;
+
+	DERLen = ssl->status_request_DER_size;
+	lsize = 1 + 3;  // 1 byte status type + 3 bytes DER length
+
+	/* TODO DTLS: Make sure this maxPtFrag is consistent with the fragment
+		extension and is not interfering with DTLS notions of fragmentation */
+	if ((DERLen + lsize + ssl->hshakeHeadLen) > ssl->maxPtFrag) {
+		return writeMultiRecordCertificateStatus(ssl, out);
+	} else {
+		messageSize =
+			ssl->recordHeadLen +
+			ssl->hshakeHeadLen +
+			lsize + DERLen;
+
+		if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+				SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+				&end, &c)) < 0) {
+			return rc;
+		}
+
+		// Write out status type
+		*c = CERTIFICATE_STATUS_OCSP; c++;
+
+		// Write out DER length and DER
+		DER = ssl->status_request_DER;
+		if (DERLen > 0) {
+			*c = (unsigned char)((DERLen & 0xFF0000) >> 16); c++;
+			*c = (DERLen & 0xFF00) >> 8; c++;
+			*c = (DERLen & 0xFF); c++;
+			memcpy(c, DER, DERLen);
+			c += DERLen;
+		}
+
+		if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+				SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+				&c)) < 0) {
+			return rc;
+		}
+		out->end = c;
+	}
+	return MATRIXSSL_SUCCESS;
+}
+
+#endif /* ENABLE_CERTIFICATE_STATUS_REQUEST */
+
 #endif /* USE_ONLY_PSK_CIPHER_SUITE */
 
 /******************************************************************************/
@@ -4097,7 +4413,7 @@
 		/* If ciphers are specified it is two bytes length and two bytes data */
 		cipherLen = 2;
 		for (i = 0; i < cipherSpecLen; i++) {
-			if ((cipherDetails = sslGetCipherSpec(ssl, cipherSpecs[i]))
+			if ((cipherDetails = sslGetCipherSpec(ssl, cipherSpecs[i], NULL))
 					== NULL) {
 				psTraceIntInfo("Cipher suite not supported: %d\n",
 					cipherSpecs[i]);
